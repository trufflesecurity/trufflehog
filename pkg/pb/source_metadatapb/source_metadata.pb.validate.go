// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: source_metadata.proto

package source_metadatapb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Azure with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Azure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Azure with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AzureMultiError, or nil if none found.
func (m *Azure) ValidateAll() error {
	return m.validate(true)
}

func (m *Azure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Container

	// no validation rules for File

	// no validation rules for Uploaded

	// no validation rules for Link

	// no validation rules for Email

	if len(errors) > 0 {
		return AzureMultiError(errors)
	}

	return nil
}

// AzureMultiError is an error wrapping multiple validation errors returned by
// Azure.ValidateAll() if the designated constraints aren't met.
type AzureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AzureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AzureMultiError) AllErrors() []error { return m }

// AzureValidationError is the validation error returned by Azure.Validate if
// the designated constraints aren't met.
type AzureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AzureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AzureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AzureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AzureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AzureValidationError) ErrorName() string { return "AzureValidationError" }

// Error satisfies the builtin error interface
func (e AzureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAzure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AzureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AzureValidationError{}

// Validate checks the field values on Bitbucket with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Bitbucket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Bitbucket with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BitbucketMultiError, or nil
// if none found.
func (m *Bitbucket) ValidateAll() error {
	return m.validate(true)
}

func (m *Bitbucket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	// no validation rules for Repository

	// no validation rules for Workspace

	// no validation rules for SnippetId

	// no validation rules for Title

	// no validation rules for Commit

	// no validation rules for Email

	// no validation rules for Link

	// no validation rules for Timestamp

	// no validation rules for Line

	if len(errors) > 0 {
		return BitbucketMultiError(errors)
	}

	return nil
}

// BitbucketMultiError is an error wrapping multiple validation errors returned
// by Bitbucket.ValidateAll() if the designated constraints aren't met.
type BitbucketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BitbucketMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BitbucketMultiError) AllErrors() []error { return m }

// BitbucketValidationError is the validation error returned by
// Bitbucket.Validate if the designated constraints aren't met.
type BitbucketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BitbucketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BitbucketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BitbucketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BitbucketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BitbucketValidationError) ErrorName() string { return "BitbucketValidationError" }

// Error satisfies the builtin error interface
func (e BitbucketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBitbucket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BitbucketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BitbucketValidationError{}

// Validate checks the field values on Buildkite with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Buildkite) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Buildkite with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BuildkiteMultiError, or nil
// if none found.
func (m *Buildkite) ValidateAll() error {
	return m.validate(true)
}

func (m *Buildkite) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Pipeline

	// no validation rules for Link

	// no validation rules for Email

	// no validation rules for BuildNumber

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return BuildkiteMultiError(errors)
	}

	return nil
}

// BuildkiteMultiError is an error wrapping multiple validation errors returned
// by Buildkite.ValidateAll() if the designated constraints aren't met.
type BuildkiteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BuildkiteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BuildkiteMultiError) AllErrors() []error { return m }

// BuildkiteValidationError is the validation error returned by
// Buildkite.Validate if the designated constraints aren't met.
type BuildkiteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BuildkiteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BuildkiteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BuildkiteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BuildkiteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BuildkiteValidationError) ErrorName() string { return "BuildkiteValidationError" }

// Error satisfies the builtin error interface
func (e BuildkiteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBuildkite.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BuildkiteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BuildkiteValidationError{}

// Validate checks the field values on CircleCI with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CircleCI) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CircleCI with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CircleCIMultiError, or nil
// if none found.
func (m *CircleCI) ValidateAll() error {
	return m.validate(true)
}

func (m *CircleCI) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VcsType

	// no validation rules for Username

	// no validation rules for Repository

	// no validation rules for BuildNumber

	// no validation rules for BuildStep

	// no validation rules for Link

	// no validation rules for Email

	if len(errors) > 0 {
		return CircleCIMultiError(errors)
	}

	return nil
}

// CircleCIMultiError is an error wrapping multiple validation errors returned
// by CircleCI.ValidateAll() if the designated constraints aren't met.
type CircleCIMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CircleCIMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CircleCIMultiError) AllErrors() []error { return m }

// CircleCIValidationError is the validation error returned by
// CircleCI.Validate if the designated constraints aren't met.
type CircleCIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CircleCIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CircleCIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CircleCIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CircleCIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CircleCIValidationError) ErrorName() string { return "CircleCIValidationError" }

// Error satisfies the builtin error interface
func (e CircleCIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCircleCI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CircleCIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CircleCIValidationError{}

// Validate checks the field values on TravisCI with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TravisCI) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TravisCI with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TravisCIMultiError, or nil
// if none found.
func (m *TravisCI) ValidateAll() error {
	return m.validate(true)
}

func (m *TravisCI) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Repository

	// no validation rules for BuildNumber

	// no validation rules for JobNumber

	// no validation rules for Link

	// no validation rules for Public

	if len(errors) > 0 {
		return TravisCIMultiError(errors)
	}

	return nil
}

// TravisCIMultiError is an error wrapping multiple validation errors returned
// by TravisCI.ValidateAll() if the designated constraints aren't met.
type TravisCIMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TravisCIMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TravisCIMultiError) AllErrors() []error { return m }

// TravisCIValidationError is the validation error returned by
// TravisCI.Validate if the designated constraints aren't met.
type TravisCIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TravisCIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TravisCIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TravisCIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TravisCIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TravisCIValidationError) ErrorName() string { return "TravisCIValidationError" }

// Error satisfies the builtin error interface
func (e TravisCIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTravisCI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TravisCIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TravisCIValidationError{}

// Validate checks the field values on Confluence with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Confluence) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Confluence with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfluenceMultiError, or
// nil if none found.
func (m *Confluence) ValidateAll() error {
	return m.validate(true)
}

func (m *Confluence) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Page

	// no validation rules for Space

	// no validation rules for Version

	// no validation rules for Link

	// no validation rules for Email

	// no validation rules for Timestamp

	// no validation rules for Location

	// no validation rules for File

	if len(errors) > 0 {
		return ConfluenceMultiError(errors)
	}

	return nil
}

// ConfluenceMultiError is an error wrapping multiple validation errors
// returned by Confluence.ValidateAll() if the designated constraints aren't met.
type ConfluenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfluenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfluenceMultiError) AllErrors() []error { return m }

// ConfluenceValidationError is the validation error returned by
// Confluence.Validate if the designated constraints aren't met.
type ConfluenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfluenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfluenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfluenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfluenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfluenceValidationError) ErrorName() string { return "ConfluenceValidationError" }

// Error satisfies the builtin error interface
func (e ConfluenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfluence.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfluenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfluenceValidationError{}

// Validate checks the field values on Docker with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Docker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Docker with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DockerMultiError, or nil if none found.
func (m *Docker) ValidateAll() error {
	return m.validate(true)
}

func (m *Docker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	// no validation rules for Image

	// no validation rules for Layer

	// no validation rules for Tag

	if len(errors) > 0 {
		return DockerMultiError(errors)
	}

	return nil
}

// DockerMultiError is an error wrapping multiple validation errors returned by
// Docker.ValidateAll() if the designated constraints aren't met.
type DockerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DockerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DockerMultiError) AllErrors() []error { return m }

// DockerValidationError is the validation error returned by Docker.Validate if
// the designated constraints aren't met.
type DockerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DockerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DockerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DockerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DockerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DockerValidationError) ErrorName() string { return "DockerValidationError" }

// Error satisfies the builtin error interface
func (e DockerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DockerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DockerValidationError{}

// Validate checks the field values on ECR with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *ECR) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ECR with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ECRMultiError, or nil if none found.
func (m *ECR) ValidateAll() error {
	return m.validate(true)
}

func (m *ECR) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	// no validation rules for Layer

	// no validation rules for Image

	// no validation rules for Registry

	// no validation rules for Region

	// no validation rules for Link

	// no validation rules for Email

	if len(errors) > 0 {
		return ECRMultiError(errors)
	}

	return nil
}

// ECRMultiError is an error wrapping multiple validation errors returned by
// ECR.ValidateAll() if the designated constraints aren't met.
type ECRMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ECRMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ECRMultiError) AllErrors() []error { return m }

// ECRValidationError is the validation error returned by ECR.Validate if the
// designated constraints aren't met.
type ECRValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ECRValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ECRValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ECRValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ECRValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ECRValidationError) ErrorName() string { return "ECRValidationError" }

// Error satisfies the builtin error interface
func (e ECRValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sECR.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ECRValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ECRValidationError{}

// Validate checks the field values on Filesystem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Filesystem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Filesystem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FilesystemMultiError, or
// nil if none found.
func (m *Filesystem) ValidateAll() error {
	return m.validate(true)
}

func (m *Filesystem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	// no validation rules for Link

	// no validation rules for Email

	// no validation rules for Line

	if len(errors) > 0 {
		return FilesystemMultiError(errors)
	}

	return nil
}

// FilesystemMultiError is an error wrapping multiple validation errors
// returned by Filesystem.ValidateAll() if the designated constraints aren't met.
type FilesystemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FilesystemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FilesystemMultiError) AllErrors() []error { return m }

// FilesystemValidationError is the validation error returned by
// Filesystem.Validate if the designated constraints aren't met.
type FilesystemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FilesystemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FilesystemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FilesystemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FilesystemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FilesystemValidationError) ErrorName() string { return "FilesystemValidationError" }

// Error satisfies the builtin error interface
func (e FilesystemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFilesystem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FilesystemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FilesystemValidationError{}

// Validate checks the field values on Git with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Git) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Git with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GitMultiError, or nil if none found.
func (m *Git) ValidateAll() error {
	return m.validate(true)
}

func (m *Git) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Commit

	// no validation rules for File

	// no validation rules for Email

	// no validation rules for Repository

	// no validation rules for Timestamp

	// no validation rules for Line

	if len(errors) > 0 {
		return GitMultiError(errors)
	}

	return nil
}

// GitMultiError is an error wrapping multiple validation errors returned by
// Git.ValidateAll() if the designated constraints aren't met.
type GitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GitMultiError) AllErrors() []error { return m }

// GitValidationError is the validation error returned by Git.Validate if the
// designated constraints aren't met.
type GitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GitValidationError) ErrorName() string { return "GitValidationError" }

// Error satisfies the builtin error interface
func (e GitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GitValidationError{}

// Validate checks the field values on Github with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Github) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Github with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GithubMultiError, or nil if none found.
func (m *Github) ValidateAll() error {
	return m.validate(true)
}

func (m *Github) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Link

	// no validation rules for Username

	// no validation rules for Repository

	// no validation rules for Commit

	// no validation rules for Email

	// no validation rules for File

	// no validation rules for Timestamp

	// no validation rules for Line

	// no validation rules for Visibility

	if len(errors) > 0 {
		return GithubMultiError(errors)
	}

	return nil
}

// GithubMultiError is an error wrapping multiple validation errors returned by
// Github.ValidateAll() if the designated constraints aren't met.
type GithubMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GithubMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GithubMultiError) AllErrors() []error { return m }

// GithubValidationError is the validation error returned by Github.Validate if
// the designated constraints aren't met.
type GithubValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GithubValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GithubValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GithubValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GithubValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GithubValidationError) ErrorName() string { return "GithubValidationError" }

// Error satisfies the builtin error interface
func (e GithubValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGithub.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GithubValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GithubValidationError{}

// Validate checks the field values on Gitlab with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Gitlab) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Gitlab with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GitlabMultiError, or nil if none found.
func (m *Gitlab) ValidateAll() error {
	return m.validate(true)
}

func (m *Gitlab) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Commit

	// no validation rules for File

	// no validation rules for Link

	// no validation rules for Email

	// no validation rules for Repository

	// no validation rules for Timestamp

	// no validation rules for Line

	// no validation rules for ProjectId

	// no validation rules for ProjectName

	// no validation rules for ProjectOwner

	if len(errors) > 0 {
		return GitlabMultiError(errors)
	}

	return nil
}

// GitlabMultiError is an error wrapping multiple validation errors returned by
// Gitlab.ValidateAll() if the designated constraints aren't met.
type GitlabMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GitlabMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GitlabMultiError) AllErrors() []error { return m }

// GitlabValidationError is the validation error returned by Gitlab.Validate if
// the designated constraints aren't met.
type GitlabValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GitlabValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GitlabValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GitlabValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GitlabValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GitlabValidationError) ErrorName() string { return "GitlabValidationError" }

// Error satisfies the builtin error interface
func (e GitlabValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGitlab.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GitlabValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GitlabValidationError{}

// Validate checks the field values on GCS with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *GCS) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GCS with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GCSMultiError, or nil if none found.
func (m *GCS) ValidateAll() error {
	return m.validate(true)
}

func (m *GCS) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bucket

	// no validation rules for Filename

	// no validation rules for Link

	// no validation rules for Email

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for ContentType

	if len(errors) > 0 {
		return GCSMultiError(errors)
	}

	return nil
}

// GCSMultiError is an error wrapping multiple validation errors returned by
// GCS.ValidateAll() if the designated constraints aren't met.
type GCSMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GCSMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GCSMultiError) AllErrors() []error { return m }

// GCSValidationError is the validation error returned by GCS.Validate if the
// designated constraints aren't met.
type GCSValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GCSValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GCSValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GCSValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GCSValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GCSValidationError) ErrorName() string { return "GCSValidationError" }

// Error satisfies the builtin error interface
func (e GCSValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGCS.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GCSValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GCSValidationError{}

// Validate checks the field values on Huggingface with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Huggingface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Huggingface with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HuggingfaceMultiError, or
// nil if none found.
func (m *Huggingface) ValidateAll() error {
	return m.validate(true)
}

func (m *Huggingface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Link

	// no validation rules for Username

	// no validation rules for Repository

	// no validation rules for Commit

	// no validation rules for Email

	// no validation rules for File

	// no validation rules for Timestamp

	// no validation rules for Line

	// no validation rules for Visibility

	// no validation rules for ResourceType

	if len(errors) > 0 {
		return HuggingfaceMultiError(errors)
	}

	return nil
}

// HuggingfaceMultiError is an error wrapping multiple validation errors
// returned by Huggingface.ValidateAll() if the designated constraints aren't met.
type HuggingfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HuggingfaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HuggingfaceMultiError) AllErrors() []error { return m }

// HuggingfaceValidationError is the validation error returned by
// Huggingface.Validate if the designated constraints aren't met.
type HuggingfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HuggingfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HuggingfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HuggingfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HuggingfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HuggingfaceValidationError) ErrorName() string { return "HuggingfaceValidationError" }

// Error satisfies the builtin error interface
func (e HuggingfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHuggingface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HuggingfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HuggingfaceValidationError{}

// Validate checks the field values on Jira with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Jira) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Jira with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JiraMultiError, or nil if none found.
func (m *Jira) ValidateAll() error {
	return m.validate(true)
}

func (m *Jira) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Issue

	// no validation rules for Author

	// no validation rules for Link

	// no validation rules for Location

	// no validation rules for Email

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return JiraMultiError(errors)
	}

	return nil
}

// JiraMultiError is an error wrapping multiple validation errors returned by
// Jira.ValidateAll() if the designated constraints aren't met.
type JiraMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JiraMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JiraMultiError) AllErrors() []error { return m }

// JiraValidationError is the validation error returned by Jira.Validate if the
// designated constraints aren't met.
type JiraValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JiraValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JiraValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JiraValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JiraValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JiraValidationError) ErrorName() string { return "JiraValidationError" }

// Error satisfies the builtin error interface
func (e JiraValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJira.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JiraValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JiraValidationError{}

// Validate checks the field values on NPM with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *NPM) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NPM with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NPMMultiError, or nil if none found.
func (m *NPM) ValidateAll() error {
	return m.validate(true)
}

func (m *NPM) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	// no validation rules for Package

	// no validation rules for Release

	// no validation rules for Link

	// no validation rules for Email

	if len(errors) > 0 {
		return NPMMultiError(errors)
	}

	return nil
}

// NPMMultiError is an error wrapping multiple validation errors returned by
// NPM.ValidateAll() if the designated constraints aren't met.
type NPMMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NPMMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NPMMultiError) AllErrors() []error { return m }

// NPMValidationError is the validation error returned by NPM.Validate if the
// designated constraints aren't met.
type NPMValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NPMValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NPMValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NPMValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NPMValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NPMValidationError) ErrorName() string { return "NPMValidationError" }

// Error satisfies the builtin error interface
func (e NPMValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNPM.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NPMValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NPMValidationError{}

// Validate checks the field values on PyPi with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *PyPi) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PyPi with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PyPiMultiError, or nil if none found.
func (m *PyPi) ValidateAll() error {
	return m.validate(true)
}

func (m *PyPi) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	// no validation rules for Package

	// no validation rules for Release

	// no validation rules for Link

	// no validation rules for Email

	if len(errors) > 0 {
		return PyPiMultiError(errors)
	}

	return nil
}

// PyPiMultiError is an error wrapping multiple validation errors returned by
// PyPi.ValidateAll() if the designated constraints aren't met.
type PyPiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PyPiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PyPiMultiError) AllErrors() []error { return m }

// PyPiValidationError is the validation error returned by PyPi.Validate if the
// designated constraints aren't met.
type PyPiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PyPiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PyPiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PyPiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PyPiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PyPiValidationError) ErrorName() string { return "PyPiValidationError" }

// Error satisfies the builtin error interface
func (e PyPiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPyPi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PyPiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PyPiValidationError{}

// Validate checks the field values on S3 with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *S3) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on S3 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in S3MultiError, or nil if none found.
func (m *S3) ValidateAll() error {
	return m.validate(true)
}

func (m *S3) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bucket

	// no validation rules for File

	// no validation rules for Link

	// no validation rules for Email

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return S3MultiError(errors)
	}

	return nil
}

// S3MultiError is an error wrapping multiple validation errors returned by
// S3.ValidateAll() if the designated constraints aren't met.
type S3MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m S3MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m S3MultiError) AllErrors() []error { return m }

// S3ValidationError is the validation error returned by S3.Validate if the
// designated constraints aren't met.
type S3ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e S3ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e S3ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e S3ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e S3ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e S3ValidationError) ErrorName() string { return "S3ValidationError" }

// Error satisfies the builtin error interface
func (e S3ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sS3.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = S3ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = S3ValidationError{}

// Validate checks the field values on Slack with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Slack) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Slack with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SlackMultiError, or nil if none found.
func (m *Slack) ValidateAll() error {
	return m.validate(true)
}

func (m *Slack) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChannelId

	// no validation rules for ChannelName

	// no validation rules for Timestamp

	// no validation rules for UserId

	// no validation rules for Link

	// no validation rules for File

	// no validation rules for Email

	// no validation rules for Visibility

	// no validation rules for Location

	if len(errors) > 0 {
		return SlackMultiError(errors)
	}

	return nil
}

// SlackMultiError is an error wrapping multiple validation errors returned by
// Slack.ValidateAll() if the designated constraints aren't met.
type SlackMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SlackMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SlackMultiError) AllErrors() []error { return m }

// SlackValidationError is the validation error returned by Slack.Validate if
// the designated constraints aren't met.
type SlackValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SlackValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SlackValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SlackValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SlackValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SlackValidationError) ErrorName() string { return "SlackValidationError" }

// Error satisfies the builtin error interface
func (e SlackValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSlack.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SlackValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SlackValidationError{}

// Validate checks the field values on Gerrit with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Gerrit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Gerrit with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GerritMultiError, or nil if none found.
func (m *Gerrit) ValidateAll() error {
	return m.validate(true)
}

func (m *Gerrit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Commit

	// no validation rules for File

	// no validation rules for Email

	// no validation rules for Project

	// no validation rules for Timestamp

	// no validation rules for Line

	if len(errors) > 0 {
		return GerritMultiError(errors)
	}

	return nil
}

// GerritMultiError is an error wrapping multiple validation errors returned by
// Gerrit.ValidateAll() if the designated constraints aren't met.
type GerritMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GerritMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GerritMultiError) AllErrors() []error { return m }

// GerritValidationError is the validation error returned by Gerrit.Validate if
// the designated constraints aren't met.
type GerritValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GerritValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GerritValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GerritValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GerritValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GerritValidationError) ErrorName() string { return "GerritValidationError" }

// Error satisfies the builtin error interface
func (e GerritValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGerrit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GerritValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GerritValidationError{}

// Validate checks the field values on Test with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Test) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Test with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TestMultiError, or nil if none found.
func (m *Test) ValidateAll() error {
	return m.validate(true)
}

func (m *Test) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	if len(errors) > 0 {
		return TestMultiError(errors)
	}

	return nil
}

// TestMultiError is an error wrapping multiple validation errors returned by
// Test.ValidateAll() if the designated constraints aren't met.
type TestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestMultiError) AllErrors() []error { return m }

// TestValidationError is the validation error returned by Test.Validate if the
// designated constraints aren't met.
type TestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestValidationError) ErrorName() string { return "TestValidationError" }

// Error satisfies the builtin error interface
func (e TestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestValidationError{}

// Validate checks the field values on Jenkins with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Jenkins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Jenkins with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JenkinsMultiError, or nil if none found.
func (m *Jenkins) ValidateAll() error {
	return m.validate(true)
}

func (m *Jenkins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectName

	// no validation rules for BuildNumber

	// no validation rules for Link

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return JenkinsMultiError(errors)
	}

	return nil
}

// JenkinsMultiError is an error wrapping multiple validation errors returned
// by Jenkins.ValidateAll() if the designated constraints aren't met.
type JenkinsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JenkinsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JenkinsMultiError) AllErrors() []error { return m }

// JenkinsValidationError is the validation error returned by Jenkins.Validate
// if the designated constraints aren't met.
type JenkinsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JenkinsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JenkinsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JenkinsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JenkinsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JenkinsValidationError) ErrorName() string { return "JenkinsValidationError" }

// Error satisfies the builtin error interface
func (e JenkinsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJenkins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JenkinsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JenkinsValidationError{}

// Validate checks the field values on Teams with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Teams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Teams with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TeamsMultiError, or nil if none found.
func (m *Teams) ValidateAll() error {
	return m.validate(true)
}

func (m *Teams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChannelId

	// no validation rules for ChannelName

	// no validation rules for Timestamp

	// no validation rules for UserId

	// no validation rules for Link

	// no validation rules for File

	// no validation rules for Email

	// no validation rules for Location

	// no validation rules for TeamName

	// no validation rules for TeamId

	if len(errors) > 0 {
		return TeamsMultiError(errors)
	}

	return nil
}

// TeamsMultiError is an error wrapping multiple validation errors returned by
// Teams.ValidateAll() if the designated constraints aren't met.
type TeamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TeamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TeamsMultiError) AllErrors() []error { return m }

// TeamsValidationError is the validation error returned by Teams.Validate if
// the designated constraints aren't met.
type TeamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TeamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TeamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TeamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TeamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TeamsValidationError) ErrorName() string { return "TeamsValidationError" }

// Error satisfies the builtin error interface
func (e TeamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTeams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TeamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TeamsValidationError{}

// Validate checks the field values on Artifactory with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Artifactory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Artifactory with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ArtifactoryMultiError, or
// nil if none found.
func (m *Artifactory) ValidateAll() error {
	return m.validate(true)
}

func (m *Artifactory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Repo

	// no validation rules for Path

	// no validation rules for Link

	// no validation rules for Timestamp

	// no validation rules for Username

	// no validation rules for Email

	if len(errors) > 0 {
		return ArtifactoryMultiError(errors)
	}

	return nil
}

// ArtifactoryMultiError is an error wrapping multiple validation errors
// returned by Artifactory.ValidateAll() if the designated constraints aren't met.
type ArtifactoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArtifactoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArtifactoryMultiError) AllErrors() []error { return m }

// ArtifactoryValidationError is the validation error returned by
// Artifactory.Validate if the designated constraints aren't met.
type ArtifactoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArtifactoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArtifactoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArtifactoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArtifactoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArtifactoryValidationError) ErrorName() string { return "ArtifactoryValidationError" }

// Error satisfies the builtin error interface
func (e ArtifactoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArtifactory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArtifactoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArtifactoryValidationError{}

// Validate checks the field values on Syslog with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Syslog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Syslog with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SyslogMultiError, or nil if none found.
func (m *Syslog) ValidateAll() error {
	return m.validate(true)
}

func (m *Syslog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hostname

	// no validation rules for Appname

	// no validation rules for Procid

	// no validation rules for Timestamp

	// no validation rules for Client

	// no validation rules for Facility

	if len(errors) > 0 {
		return SyslogMultiError(errors)
	}

	return nil
}

// SyslogMultiError is an error wrapping multiple validation errors returned by
// Syslog.ValidateAll() if the designated constraints aren't met.
type SyslogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyslogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyslogMultiError) AllErrors() []error { return m }

// SyslogValidationError is the validation error returned by Syslog.Validate if
// the designated constraints aren't met.
type SyslogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyslogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyslogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyslogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyslogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyslogValidationError) ErrorName() string { return "SyslogValidationError" }

// Error satisfies the builtin error interface
func (e SyslogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyslog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyslogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyslogValidationError{}

// Validate checks the field values on Forager with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Forager) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Forager with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ForagerMultiError, or nil if none found.
func (m *Forager) ValidateAll() error {
	return m.validate(true)
}

func (m *Forager) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Metadata.(type) {
	case *Forager_Github:
		if v == nil {
			err := ForagerValidationError{
				field:  "Metadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGithub()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ForagerValidationError{
						field:  "Github",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ForagerValidationError{
						field:  "Github",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGithub()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ForagerValidationError{
					field:  "Github",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Forager_Npm:
		if v == nil {
			err := ForagerValidationError{
				field:  "Metadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNpm()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ForagerValidationError{
						field:  "Npm",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ForagerValidationError{
						field:  "Npm",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNpm()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ForagerValidationError{
					field:  "Npm",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Forager_Pypi:
		if v == nil {
			err := ForagerValidationError{
				field:  "Metadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPypi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ForagerValidationError{
						field:  "Pypi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ForagerValidationError{
						field:  "Pypi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPypi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ForagerValidationError{
					field:  "Pypi",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ForagerMultiError(errors)
	}

	return nil
}

// ForagerMultiError is an error wrapping multiple validation errors returned
// by Forager.ValidateAll() if the designated constraints aren't met.
type ForagerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForagerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForagerMultiError) AllErrors() []error { return m }

// ForagerValidationError is the validation error returned by Forager.Validate
// if the designated constraints aren't met.
type ForagerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForagerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForagerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForagerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForagerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForagerValidationError) ErrorName() string { return "ForagerValidationError" }

// Error satisfies the builtin error interface
func (e ForagerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForager.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForagerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForagerValidationError{}

// Validate checks the field values on SharePoint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SharePoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SharePoint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SharePointMultiError, or
// nil if none found.
func (m *SharePoint) ValidateAll() error {
	return m.validate(true)
}

func (m *SharePoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Link

	// no validation rules for Timestamp

	// no validation rules for Author

	// no validation rules for Title

	// no validation rules for Views

	// no validation rules for Docid

	// no validation rules for Email

	if len(errors) > 0 {
		return SharePointMultiError(errors)
	}

	return nil
}

// SharePointMultiError is an error wrapping multiple validation errors
// returned by SharePoint.ValidateAll() if the designated constraints aren't met.
type SharePointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SharePointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SharePointMultiError) AllErrors() []error { return m }

// SharePointValidationError is the validation error returned by
// SharePoint.Validate if the designated constraints aren't met.
type SharePointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SharePointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SharePointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SharePointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SharePointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SharePointValidationError) ErrorName() string { return "SharePointValidationError" }

// Error satisfies the builtin error interface
func (e SharePointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSharePoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SharePointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SharePointValidationError{}

// Validate checks the field values on GoogleDrive with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GoogleDrive) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GoogleDrive with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GoogleDriveMultiError, or
// nil if none found.
func (m *GoogleDrive) ValidateAll() error {
	return m.validate(true)
}

func (m *GoogleDrive) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	// no validation rules for Link

	// no validation rules for Email

	// no validation rules for Timestamp

	// no validation rules for Shared

	// no validation rules for LastModifiedBy

	// no validation rules for Path

	if len(errors) > 0 {
		return GoogleDriveMultiError(errors)
	}

	return nil
}

// GoogleDriveMultiError is an error wrapping multiple validation errors
// returned by GoogleDrive.ValidateAll() if the designated constraints aren't met.
type GoogleDriveMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GoogleDriveMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GoogleDriveMultiError) AllErrors() []error { return m }

// GoogleDriveValidationError is the validation error returned by
// GoogleDrive.Validate if the designated constraints aren't met.
type GoogleDriveValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GoogleDriveValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GoogleDriveValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GoogleDriveValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GoogleDriveValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GoogleDriveValidationError) ErrorName() string { return "GoogleDriveValidationError" }

// Error satisfies the builtin error interface
func (e GoogleDriveValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGoogleDrive.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GoogleDriveValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GoogleDriveValidationError{}

// Validate checks the field values on AzureRepos with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AzureRepos) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AzureRepos with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AzureReposMultiError, or
// nil if none found.
func (m *AzureRepos) ValidateAll() error {
	return m.validate(true)
}

func (m *AzureRepos) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Link

	// no validation rules for Username

	// no validation rules for Repository

	// no validation rules for Commit

	// no validation rules for Email

	// no validation rules for File

	// no validation rules for Timestamp

	// no validation rules for Line

	// no validation rules for Visibility

	// no validation rules for Project

	// no validation rules for Organization

	if len(errors) > 0 {
		return AzureReposMultiError(errors)
	}

	return nil
}

// AzureReposMultiError is an error wrapping multiple validation errors
// returned by AzureRepos.ValidateAll() if the designated constraints aren't met.
type AzureReposMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AzureReposMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AzureReposMultiError) AllErrors() []error { return m }

// AzureReposValidationError is the validation error returned by
// AzureRepos.Validate if the designated constraints aren't met.
type AzureReposValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AzureReposValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AzureReposValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AzureReposValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AzureReposValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AzureReposValidationError) ErrorName() string { return "AzureReposValidationError" }

// Error satisfies the builtin error interface
func (e AzureReposValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAzureRepos.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AzureReposValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AzureReposValidationError{}

// Validate checks the field values on Postman with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Postman) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Postman with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PostmanMultiError, or nil if none found.
func (m *Postman) ValidateAll() error {
	return m.validate(true)
}

func (m *Postman) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Link

	// no validation rules for WorkspaceUuid

	// no validation rules for WorkspaceName

	// no validation rules for CollectionId

	// no validation rules for CollectionName

	// no validation rules for EnvironmentId

	// no validation rules for EnvironmentName

	// no validation rules for RequestId

	// no validation rules for RequestName

	// no validation rules for FolderId

	// no validation rules for FolderName

	// no validation rules for FieldType

	// no validation rules for LocationType

	if len(errors) > 0 {
		return PostmanMultiError(errors)
	}

	return nil
}

// PostmanMultiError is an error wrapping multiple validation errors returned
// by Postman.ValidateAll() if the designated constraints aren't met.
type PostmanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostmanMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostmanMultiError) AllErrors() []error { return m }

// PostmanValidationError is the validation error returned by Postman.Validate
// if the designated constraints aren't met.
type PostmanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostmanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostmanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostmanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostmanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostmanValidationError) ErrorName() string { return "PostmanValidationError" }

// Error satisfies the builtin error interface
func (e PostmanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostman.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostmanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostmanValidationError{}

// Validate checks the field values on Vector with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Vector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Vector with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VectorMultiError, or nil if none found.
func (m *Vector) ValidateAll() error {
	return m.validate(true)
}

func (m *Vector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VectorValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VectorValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VectorValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SourceType

	// no validation rules for Host

	if len(errors) > 0 {
		return VectorMultiError(errors)
	}

	return nil
}

// VectorMultiError is an error wrapping multiple validation errors returned by
// Vector.ValidateAll() if the designated constraints aren't met.
type VectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VectorMultiError) AllErrors() []error { return m }

// VectorValidationError is the validation error returned by Vector.Validate if
// the designated constraints aren't met.
type VectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VectorValidationError) ErrorName() string { return "VectorValidationError" }

// Error satisfies the builtin error interface
func (e VectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VectorValidationError{}

// Validate checks the field values on Webhook with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Webhook) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Webhook with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in WebhookMultiError, or nil if none found.
func (m *Webhook) ValidateAll() error {
	return m.validate(true)
}

func (m *Webhook) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Data.(type) {
	case *Webhook_Vector:
		if v == nil {
			err := WebhookValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetVector()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WebhookValidationError{
						field:  "Vector",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WebhookValidationError{
						field:  "Vector",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVector()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WebhookValidationError{
					field:  "Vector",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return WebhookMultiError(errors)
	}

	return nil
}

// WebhookMultiError is an error wrapping multiple validation errors returned
// by Webhook.ValidateAll() if the designated constraints aren't met.
type WebhookMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebhookMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebhookMultiError) AllErrors() []error { return m }

// WebhookValidationError is the validation error returned by Webhook.Validate
// if the designated constraints aren't met.
type WebhookValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebhookValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebhookValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebhookValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebhookValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebhookValidationError) ErrorName() string { return "WebhookValidationError" }

// Error satisfies the builtin error interface
func (e WebhookValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebhook.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebhookValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebhookValidationError{}

// Validate checks the field values on Elasticsearch with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Elasticsearch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Elasticsearch with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ElasticsearchMultiError, or
// nil if none found.
func (m *Elasticsearch) ValidateAll() error {
	return m.validate(true)
}

func (m *Elasticsearch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	// no validation rules for DocumentId

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return ElasticsearchMultiError(errors)
	}

	return nil
}

// ElasticsearchMultiError is an error wrapping multiple validation errors
// returned by Elasticsearch.ValidateAll() if the designated constraints
// aren't met.
type ElasticsearchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ElasticsearchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ElasticsearchMultiError) AllErrors() []error { return m }

// ElasticsearchValidationError is the validation error returned by
// Elasticsearch.Validate if the designated constraints aren't met.
type ElasticsearchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ElasticsearchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ElasticsearchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ElasticsearchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ElasticsearchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ElasticsearchValidationError) ErrorName() string { return "ElasticsearchValidationError" }

// Error satisfies the builtin error interface
func (e ElasticsearchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sElasticsearch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ElasticsearchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ElasticsearchValidationError{}

// Validate checks the field values on Sentry with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Sentry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Sentry with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SentryMultiError, or nil if none found.
func (m *Sentry) ValidateAll() error {
	return m.validate(true)
}

func (m *Sentry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for OrganizationId

	// no validation rules for OrganizationSlug

	// no validation rules for OrganizationDateCreated

	// no validation rules for ProjectId

	// no validation rules for ProjectSlug

	// no validation rules for IssueId

	// no validation rules for DateCreated

	// no validation rules for Link

	if len(errors) > 0 {
		return SentryMultiError(errors)
	}

	return nil
}

// SentryMultiError is an error wrapping multiple validation errors returned by
// Sentry.ValidateAll() if the designated constraints aren't met.
type SentryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SentryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SentryMultiError) AllErrors() []error { return m }

// SentryValidationError is the validation error returned by Sentry.Validate if
// the designated constraints aren't met.
type SentryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SentryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SentryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SentryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SentryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SentryValidationError) ErrorName() string { return "SentryValidationError" }

// Error satisfies the builtin error interface
func (e SentryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSentry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SentryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SentryValidationError{}

// Validate checks the field values on MetaData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetaData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetaData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetaDataMultiError, or nil
// if none found.
func (m *MetaData) ValidateAll() error {
	return m.validate(true)
}

func (m *MetaData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Data.(type) {
	case *MetaData_Azure:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAzure()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Azure",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAzure()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Azure",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Bitbucket:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBitbucket()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Bitbucket",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Bitbucket",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBitbucket()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Bitbucket",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Circleci:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCircleci()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Circleci",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Circleci",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCircleci()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Circleci",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Confluence:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConfluence()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Confluence",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Confluence",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConfluence()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Confluence",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Docker:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDocker()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Docker",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Docker",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDocker()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Docker",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Ecr:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEcr()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Ecr",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Ecr",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEcr()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Ecr",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Gcs:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGcs()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Gcs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Gcs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGcs()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Gcs",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Github:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGithub()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Github",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Github",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGithub()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Github",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Gitlab:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGitlab()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Gitlab",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Gitlab",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGitlab()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Gitlab",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Jira:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJira()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Jira",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Jira",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJira()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Jira",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Npm:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNpm()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Npm",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Npm",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNpm()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Npm",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Pypi:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPypi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Pypi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Pypi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPypi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Pypi",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_S3:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetS3()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetS3()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "S3",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Slack:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSlack()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Slack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Slack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSlack()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Slack",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Filesystem:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFilesystem()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Filesystem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Filesystem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFilesystem()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Filesystem",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Git:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Git",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Git",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Git",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Test:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Test",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Test",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Test",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Buildkite:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBuildkite()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Buildkite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Buildkite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBuildkite()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Buildkite",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Gerrit:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGerrit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Gerrit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Gerrit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGerrit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Gerrit",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Jenkins:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJenkins()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Jenkins",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Jenkins",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJenkins()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Jenkins",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Teams:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTeams()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Teams",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Teams",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTeams()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Teams",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Artifactory:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetArtifactory()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Artifactory",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Artifactory",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetArtifactory()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Artifactory",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Syslog:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSyslog()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Syslog",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Syslog",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSyslog()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Syslog",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Forager:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetForager()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Forager",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Forager",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetForager()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Forager",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Sharepoint:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSharepoint()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Sharepoint",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Sharepoint",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSharepoint()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Sharepoint",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_GoogleDrive:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGoogleDrive()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "GoogleDrive",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "GoogleDrive",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGoogleDrive()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "GoogleDrive",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_AzureRepos:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAzureRepos()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "AzureRepos",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "AzureRepos",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAzureRepos()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "AzureRepos",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_TravisCI:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTravisCI()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "TravisCI",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "TravisCI",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTravisCI()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "TravisCI",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Postman:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPostman()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Postman",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Postman",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPostman()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Postman",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Webhook:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWebhook()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Webhook",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Webhook",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWebhook()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Webhook",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Elasticsearch:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetElasticsearch()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Elasticsearch",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Elasticsearch",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetElasticsearch()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Elasticsearch",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Huggingface:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHuggingface()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Huggingface",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Huggingface",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHuggingface()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Huggingface",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetaData_Sentry:
		if v == nil {
			err := MetaDataValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSentry()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Sentry",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaDataValidationError{
						field:  "Sentry",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSentry()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaDataValidationError{
					field:  "Sentry",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return MetaDataMultiError(errors)
	}

	return nil
}

// MetaDataMultiError is an error wrapping multiple validation errors returned
// by MetaData.ValidateAll() if the designated constraints aren't met.
type MetaDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetaDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetaDataMultiError) AllErrors() []error { return m }

// MetaDataValidationError is the validation error returned by
// MetaData.Validate if the designated constraints aren't met.
type MetaDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetaDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetaDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetaDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetaDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetaDataValidationError) ErrorName() string { return "MetaDataValidationError" }

// Error satisfies the builtin error interface
func (e MetaDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetaData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetaDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetaDataValidationError{}
