// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: sources.proto

package sourcespb

import (
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	credentialspb "github.com/trufflesecurity/trufflehog/v3/pkg/pb/credentialspb"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SourceType int32

const (
	SourceType_SOURCE_TYPE_AZURE_STORAGE              SourceType = 0
	SourceType_SOURCE_TYPE_BITBUCKET                  SourceType = 1
	SourceType_SOURCE_TYPE_CIRCLECI                   SourceType = 2
	SourceType_SOURCE_TYPE_CONFLUENCE                 SourceType = 3
	SourceType_SOURCE_TYPE_DOCKER                     SourceType = 4
	SourceType_SOURCE_TYPE_ECR                        SourceType = 5
	SourceType_SOURCE_TYPE_GCS                        SourceType = 6
	SourceType_SOURCE_TYPE_GITHUB                     SourceType = 7
	SourceType_SOURCE_TYPE_PUBLIC_GIT                 SourceType = 8
	SourceType_SOURCE_TYPE_GITLAB                     SourceType = 9
	SourceType_SOURCE_TYPE_JIRA                       SourceType = 10
	SourceType_SOURCE_TYPE_NPM_UNAUTHD_PACKAGES       SourceType = 11
	SourceType_SOURCE_TYPE_PYPI_UNAUTHD_PACKAGES      SourceType = 12
	SourceType_SOURCE_TYPE_S3                         SourceType = 13
	SourceType_SOURCE_TYPE_SLACK                      SourceType = 14
	SourceType_SOURCE_TYPE_FILESYSTEM                 SourceType = 15
	SourceType_SOURCE_TYPE_GIT                        SourceType = 16
	SourceType_SOURCE_TYPE_TEST                       SourceType = 17
	SourceType_SOURCE_TYPE_S3_UNAUTHED                SourceType = 18
	SourceType_SOURCE_TYPE_GITHUB_UNAUTHENTICATED_ORG SourceType = 19
	SourceType_SOURCE_TYPE_BUILDKITE                  SourceType = 20
	SourceType_SOURCE_TYPE_GERRIT                     SourceType = 21
	SourceType_SOURCE_TYPE_JENKINS                    SourceType = 22
	SourceType_SOURCE_TYPE_TEAMS                      SourceType = 23
	SourceType_SOURCE_TYPE_JFROG_ARTIFACTORY          SourceType = 24
	SourceType_SOURCE_TYPE_SYSLOG                     SourceType = 25
	SourceType_SOURCE_TYPE_PUBLIC_EVENT_MONITORING    SourceType = 26
	SourceType_SOURCE_TYPE_SLACK_REALTIME             SourceType = 27
	SourceType_SOURCE_TYPE_GOOGLE_DRIVE               SourceType = 28
	SourceType_SOURCE_TYPE_SHAREPOINT                 SourceType = 29
	SourceType_SOURCE_TYPE_GCS_UNAUTHED               SourceType = 30
	SourceType_SOURCE_TYPE_AZURE_REPOS                SourceType = 31
	SourceType_SOURCE_TYPE_TRAVISCI                   SourceType = 32
	SourceType_SOURCE_TYPE_POSTMAN                    SourceType = 33
	SourceType_SOURCE_TYPE_WEBHOOK                    SourceType = 34
	SourceType_SOURCE_TYPE_ELASTICSEARCH              SourceType = 35
	SourceType_SOURCE_TYPE_HUGGINGFACE                SourceType = 36
	SourceType_SOURCE_TYPE_GITHUB_EXPERIMENTAL        SourceType = 37
	SourceType_SOURCE_TYPE_SENTRY                     SourceType = 38
	SourceType_SOURCE_TYPE_GITHUB_REALTIME            SourceType = 39
	SourceType_SOURCE_TYPE_STDIN                      SourceType = 40
	SourceType_SOURCE_TYPE_SLACK_CONTINUOUS           SourceType = 41
)

// Enum value maps for SourceType.
var (
	SourceType_name = map[int32]string{
		0:  "SOURCE_TYPE_AZURE_STORAGE",
		1:  "SOURCE_TYPE_BITBUCKET",
		2:  "SOURCE_TYPE_CIRCLECI",
		3:  "SOURCE_TYPE_CONFLUENCE",
		4:  "SOURCE_TYPE_DOCKER",
		5:  "SOURCE_TYPE_ECR",
		6:  "SOURCE_TYPE_GCS",
		7:  "SOURCE_TYPE_GITHUB",
		8:  "SOURCE_TYPE_PUBLIC_GIT",
		9:  "SOURCE_TYPE_GITLAB",
		10: "SOURCE_TYPE_JIRA",
		11: "SOURCE_TYPE_NPM_UNAUTHD_PACKAGES",
		12: "SOURCE_TYPE_PYPI_UNAUTHD_PACKAGES",
		13: "SOURCE_TYPE_S3",
		14: "SOURCE_TYPE_SLACK",
		15: "SOURCE_TYPE_FILESYSTEM",
		16: "SOURCE_TYPE_GIT",
		17: "SOURCE_TYPE_TEST",
		18: "SOURCE_TYPE_S3_UNAUTHED",
		19: "SOURCE_TYPE_GITHUB_UNAUTHENTICATED_ORG",
		20: "SOURCE_TYPE_BUILDKITE",
		21: "SOURCE_TYPE_GERRIT",
		22: "SOURCE_TYPE_JENKINS",
		23: "SOURCE_TYPE_TEAMS",
		24: "SOURCE_TYPE_JFROG_ARTIFACTORY",
		25: "SOURCE_TYPE_SYSLOG",
		26: "SOURCE_TYPE_PUBLIC_EVENT_MONITORING",
		27: "SOURCE_TYPE_SLACK_REALTIME",
		28: "SOURCE_TYPE_GOOGLE_DRIVE",
		29: "SOURCE_TYPE_SHAREPOINT",
		30: "SOURCE_TYPE_GCS_UNAUTHED",
		31: "SOURCE_TYPE_AZURE_REPOS",
		32: "SOURCE_TYPE_TRAVISCI",
		33: "SOURCE_TYPE_POSTMAN",
		34: "SOURCE_TYPE_WEBHOOK",
		35: "SOURCE_TYPE_ELASTICSEARCH",
		36: "SOURCE_TYPE_HUGGINGFACE",
		37: "SOURCE_TYPE_GITHUB_EXPERIMENTAL",
		38: "SOURCE_TYPE_SENTRY",
		39: "SOURCE_TYPE_GITHUB_REALTIME",
		40: "SOURCE_TYPE_STDIN",
		41: "SOURCE_TYPE_SLACK_CONTINUOUS",
	}
	SourceType_value = map[string]int32{
		"SOURCE_TYPE_AZURE_STORAGE":              0,
		"SOURCE_TYPE_BITBUCKET":                  1,
		"SOURCE_TYPE_CIRCLECI":                   2,
		"SOURCE_TYPE_CONFLUENCE":                 3,
		"SOURCE_TYPE_DOCKER":                     4,
		"SOURCE_TYPE_ECR":                        5,
		"SOURCE_TYPE_GCS":                        6,
		"SOURCE_TYPE_GITHUB":                     7,
		"SOURCE_TYPE_PUBLIC_GIT":                 8,
		"SOURCE_TYPE_GITLAB":                     9,
		"SOURCE_TYPE_JIRA":                       10,
		"SOURCE_TYPE_NPM_UNAUTHD_PACKAGES":       11,
		"SOURCE_TYPE_PYPI_UNAUTHD_PACKAGES":      12,
		"SOURCE_TYPE_S3":                         13,
		"SOURCE_TYPE_SLACK":                      14,
		"SOURCE_TYPE_FILESYSTEM":                 15,
		"SOURCE_TYPE_GIT":                        16,
		"SOURCE_TYPE_TEST":                       17,
		"SOURCE_TYPE_S3_UNAUTHED":                18,
		"SOURCE_TYPE_GITHUB_UNAUTHENTICATED_ORG": 19,
		"SOURCE_TYPE_BUILDKITE":                  20,
		"SOURCE_TYPE_GERRIT":                     21,
		"SOURCE_TYPE_JENKINS":                    22,
		"SOURCE_TYPE_TEAMS":                      23,
		"SOURCE_TYPE_JFROG_ARTIFACTORY":          24,
		"SOURCE_TYPE_SYSLOG":                     25,
		"SOURCE_TYPE_PUBLIC_EVENT_MONITORING":    26,
		"SOURCE_TYPE_SLACK_REALTIME":             27,
		"SOURCE_TYPE_GOOGLE_DRIVE":               28,
		"SOURCE_TYPE_SHAREPOINT":                 29,
		"SOURCE_TYPE_GCS_UNAUTHED":               30,
		"SOURCE_TYPE_AZURE_REPOS":                31,
		"SOURCE_TYPE_TRAVISCI":                   32,
		"SOURCE_TYPE_POSTMAN":                    33,
		"SOURCE_TYPE_WEBHOOK":                    34,
		"SOURCE_TYPE_ELASTICSEARCH":              35,
		"SOURCE_TYPE_HUGGINGFACE":                36,
		"SOURCE_TYPE_GITHUB_EXPERIMENTAL":        37,
		"SOURCE_TYPE_SENTRY":                     38,
		"SOURCE_TYPE_GITHUB_REALTIME":            39,
		"SOURCE_TYPE_STDIN":                      40,
		"SOURCE_TYPE_SLACK_CONTINUOUS":           41,
	}
)

func (x SourceType) Enum() *SourceType {
	p := new(SourceType)
	*p = x
	return p
}

func (x SourceType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SourceType) Descriptor() protoreflect.EnumDescriptor {
	return file_sources_proto_enumTypes[0].Descriptor()
}

func (SourceType) Type() protoreflect.EnumType {
	return &file_sources_proto_enumTypes[0]
}

func (x SourceType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SourceType.Descriptor instead.
func (SourceType) EnumDescriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{0}
}

type BitbucketInstallationType int32

const (
	BitbucketInstallationType_AUTODETECT  BitbucketInstallationType = 0
	BitbucketInstallationType_CLOUD       BitbucketInstallationType = 1
	BitbucketInstallationType_DATA_CENTER BitbucketInstallationType = 2
)

// Enum value maps for BitbucketInstallationType.
var (
	BitbucketInstallationType_name = map[int32]string{
		0: "AUTODETECT",
		1: "CLOUD",
		2: "DATA_CENTER",
	}
	BitbucketInstallationType_value = map[string]int32{
		"AUTODETECT":  0,
		"CLOUD":       1,
		"DATA_CENTER": 2,
	}
)

func (x BitbucketInstallationType) Enum() *BitbucketInstallationType {
	p := new(BitbucketInstallationType)
	*p = x
	return p
}

func (x BitbucketInstallationType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BitbucketInstallationType) Descriptor() protoreflect.EnumDescriptor {
	return file_sources_proto_enumTypes[1].Descriptor()
}

func (BitbucketInstallationType) Type() protoreflect.EnumType {
	return &file_sources_proto_enumTypes[1]
}

func (x BitbucketInstallationType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BitbucketInstallationType.Descriptor instead.
func (BitbucketInstallationType) EnumDescriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{1}
}

type Confluence_GetAllSpacesScope int32

const (
	Confluence_ALL      Confluence_GetAllSpacesScope = 0
	Confluence_GLOBAL   Confluence_GetAllSpacesScope = 1
	Confluence_PERSONAL Confluence_GetAllSpacesScope = 2
)

// Enum value maps for Confluence_GetAllSpacesScope.
var (
	Confluence_GetAllSpacesScope_name = map[int32]string{
		0: "ALL",
		1: "GLOBAL",
		2: "PERSONAL",
	}
	Confluence_GetAllSpacesScope_value = map[string]int32{
		"ALL":      0,
		"GLOBAL":   1,
		"PERSONAL": 2,
	}
)

func (x Confluence_GetAllSpacesScope) Enum() *Confluence_GetAllSpacesScope {
	p := new(Confluence_GetAllSpacesScope)
	*p = x
	return p
}

func (x Confluence_GetAllSpacesScope) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Confluence_GetAllSpacesScope) Descriptor() protoreflect.EnumDescriptor {
	return file_sources_proto_enumTypes[2].Descriptor()
}

func (Confluence_GetAllSpacesScope) Type() protoreflect.EnumType {
	return &file_sources_proto_enumTypes[2]
}

func (x Confluence_GetAllSpacesScope) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Confluence_GetAllSpacesScope.Descriptor instead.
func (Confluence_GetAllSpacesScope) EnumDescriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{6, 0}
}

type LocalSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Type  string                 `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Name  string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// DEPRECATED: scan_interval is deprecated and can be removed when we no longer depend on the name.
	// Deprecating in favor of scan_period due to the fact that scan_interval is a duration
	// which is a fixed-length span of time represented as a count of seconds and fractions of seconds
	// at nanosecond resolution. Most of the time, we want to be able to specify a scan interval in
	// human-readable format (e.g. 45s, 30m, 12h, etc.) which is not possible with a duration.
	// https://protobuf.dev/reference/protobuf/google.protobuf/#duration
	//
	// Deprecated: Marked as deprecated in sources.proto.
	ScanInterval  *durationpb.Duration `protobuf:"bytes,3,opt,name=scan_interval,json=scanInterval,proto3" json:"scan_interval,omitempty"`
	Verify        bool                 `protobuf:"varint,4,opt,name=verify,proto3" json:"verify,omitempty"`
	Connection    *anypb.Any           `protobuf:"bytes,5,opt,name=connection,proto3" json:"connection,omitempty"`
	ScanPeriod    string               `protobuf:"bytes,6,opt,name=scan_period,json=scanPeriod,proto3" json:"scan_period,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LocalSource) Reset() {
	*x = LocalSource{}
	mi := &file_sources_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LocalSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LocalSource) ProtoMessage() {}

func (x *LocalSource) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LocalSource.ProtoReflect.Descriptor instead.
func (*LocalSource) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{0}
}

func (x *LocalSource) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *LocalSource) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// Deprecated: Marked as deprecated in sources.proto.
func (x *LocalSource) GetScanInterval() *durationpb.Duration {
	if x != nil {
		return x.ScanInterval
	}
	return nil
}

func (x *LocalSource) GetVerify() bool {
	if x != nil {
		return x.Verify
	}
	return false
}

func (x *LocalSource) GetConnection() *anypb.Any {
	if x != nil {
		return x.Connection
	}
	return nil
}

func (x *LocalSource) GetScanPeriod() string {
	if x != nil {
		return x.ScanPeriod
	}
	return ""
}

// https://www.jfrog.com/confluence/display/JFROG/Artifactory+REST+API#ArtifactoryRESTAPI-RetrieveFolderorRepositoryArchive
type Artifactory struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Artifactory_BasicAuth
	//	*Artifactory_AccessToken
	//	*Artifactory_Unauthenticated
	Credential    isArtifactory_Credential `protobuf_oneof:"credential"`
	Repositories  []string                 `protobuf:"bytes,4,rep,name=repositories,proto3" json:"repositories,omitempty"`
	IncludePaths  []string                 `protobuf:"bytes,5,rep,name=include_paths,json=includePaths,proto3" json:"include_paths,omitempty"`
	IgnorePaths   []string                 `protobuf:"bytes,6,rep,name=ignore_paths,json=ignorePaths,proto3" json:"ignore_paths,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Artifactory) Reset() {
	*x = Artifactory{}
	mi := &file_sources_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Artifactory) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Artifactory) ProtoMessage() {}

func (x *Artifactory) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Artifactory.ProtoReflect.Descriptor instead.
func (*Artifactory) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{1}
}

func (x *Artifactory) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *Artifactory) GetCredential() isArtifactory_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Artifactory) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*Artifactory_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *Artifactory) GetAccessToken() string {
	if x != nil {
		if x, ok := x.Credential.(*Artifactory_AccessToken); ok {
			return x.AccessToken
		}
	}
	return ""
}

func (x *Artifactory) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*Artifactory_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *Artifactory) GetRepositories() []string {
	if x != nil {
		return x.Repositories
	}
	return nil
}

func (x *Artifactory) GetIncludePaths() []string {
	if x != nil {
		return x.IncludePaths
	}
	return nil
}

func (x *Artifactory) GetIgnorePaths() []string {
	if x != nil {
		return x.IgnorePaths
	}
	return nil
}

type isArtifactory_Credential interface {
	isArtifactory_Credential()
}

type Artifactory_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,2,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

type Artifactory_AccessToken struct {
	AccessToken string `protobuf:"bytes,3,opt,name=access_token,json=accessToken,proto3,oneof"`
}

type Artifactory_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,7,opt,name=unauthenticated,proto3,oneof"`
}

func (*Artifactory_BasicAuth) isArtifactory_Credential() {}

func (*Artifactory_AccessToken) isArtifactory_Credential() {}

func (*Artifactory_Unauthenticated) isArtifactory_Credential() {}

type AzureStorage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*AzureStorage_ConnectionString
	//	*AzureStorage_BasicAuth
	//	*AzureStorage_ClientCertificate
	//	*AzureStorage_Unauthenticated
	Credential        isAzureStorage_Credential `protobuf_oneof:"credential"`
	StorageContainers []string                  `protobuf:"bytes,5,rep,name=storage_containers,json=storageContainers,proto3" json:"storage_containers,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AzureStorage) Reset() {
	*x = AzureStorage{}
	mi := &file_sources_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AzureStorage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AzureStorage) ProtoMessage() {}

func (x *AzureStorage) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AzureStorage.ProtoReflect.Descriptor instead.
func (*AzureStorage) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{2}
}

func (x *AzureStorage) GetCredential() isAzureStorage_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *AzureStorage) GetConnectionString() string {
	if x != nil {
		if x, ok := x.Credential.(*AzureStorage_ConnectionString); ok {
			return x.ConnectionString
		}
	}
	return ""
}

func (x *AzureStorage) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*AzureStorage_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *AzureStorage) GetClientCertificate() string {
	if x != nil {
		if x, ok := x.Credential.(*AzureStorage_ClientCertificate); ok {
			return x.ClientCertificate
		}
	}
	return ""
}

func (x *AzureStorage) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*AzureStorage_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *AzureStorage) GetStorageContainers() []string {
	if x != nil {
		return x.StorageContainers
	}
	return nil
}

type isAzureStorage_Credential interface {
	isAzureStorage_Credential()
}

type AzureStorage_ConnectionString struct {
	ConnectionString string `protobuf:"bytes,1,opt,name=connection_string,json=connectionString,proto3,oneof"`
}

type AzureStorage_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,2,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

type AzureStorage_ClientCertificate struct {
	ClientCertificate string `protobuf:"bytes,3,opt,name=client_certificate,json=clientCertificate,proto3,oneof"`
}

type AzureStorage_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,4,opt,name=unauthenticated,proto3,oneof"`
}

func (*AzureStorage_ConnectionString) isAzureStorage_Credential() {}

func (*AzureStorage_BasicAuth) isAzureStorage_Credential() {}

func (*AzureStorage_ClientCertificate) isAzureStorage_Credential() {}

func (*AzureStorage_Unauthenticated) isAzureStorage_Credential() {}

type Bitbucket struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Bitbucket_Token
	//	*Bitbucket_Oauth
	//	*Bitbucket_BasicAuth
	Credential       isBitbucket_Credential    `protobuf_oneof:"credential"`
	Repositories     []string                  `protobuf:"bytes,5,rep,name=repositories,proto3" json:"repositories,omitempty"`
	IgnoreRepos      []string                  `protobuf:"bytes,6,rep,name=ignore_repos,json=ignoreRepos,proto3" json:"ignore_repos,omitempty"`
	SkipBinaries     bool                      `protobuf:"varint,7,opt,name=skip_binaries,json=skipBinaries,proto3" json:"skip_binaries,omitempty"`
	SkipArchives     bool                      `protobuf:"varint,8,opt,name=skip_archives,json=skipArchives,proto3" json:"skip_archives,omitempty"`
	InstallationType BitbucketInstallationType `protobuf:"varint,9,opt,name=installation_type,json=installationType,proto3,enum=sources.BitbucketInstallationType" json:"installation_type,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Bitbucket) Reset() {
	*x = Bitbucket{}
	mi := &file_sources_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Bitbucket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Bitbucket) ProtoMessage() {}

func (x *Bitbucket) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Bitbucket.ProtoReflect.Descriptor instead.
func (*Bitbucket) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{3}
}

func (x *Bitbucket) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *Bitbucket) GetCredential() isBitbucket_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Bitbucket) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*Bitbucket_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *Bitbucket) GetOauth() *credentialspb.Oauth2 {
	if x != nil {
		if x, ok := x.Credential.(*Bitbucket_Oauth); ok {
			return x.Oauth
		}
	}
	return nil
}

func (x *Bitbucket) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*Bitbucket_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *Bitbucket) GetRepositories() []string {
	if x != nil {
		return x.Repositories
	}
	return nil
}

func (x *Bitbucket) GetIgnoreRepos() []string {
	if x != nil {
		return x.IgnoreRepos
	}
	return nil
}

func (x *Bitbucket) GetSkipBinaries() bool {
	if x != nil {
		return x.SkipBinaries
	}
	return false
}

func (x *Bitbucket) GetSkipArchives() bool {
	if x != nil {
		return x.SkipArchives
	}
	return false
}

func (x *Bitbucket) GetInstallationType() BitbucketInstallationType {
	if x != nil {
		return x.InstallationType
	}
	return BitbucketInstallationType_AUTODETECT
}

type isBitbucket_Credential interface {
	isBitbucket_Credential()
}

type Bitbucket_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}

type Bitbucket_Oauth struct {
	Oauth *credentialspb.Oauth2 `protobuf:"bytes,3,opt,name=oauth,proto3,oneof"`
}

type Bitbucket_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,4,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

func (*Bitbucket_Token) isBitbucket_Credential() {}

func (*Bitbucket_Oauth) isBitbucket_Credential() {}

func (*Bitbucket_BasicAuth) isBitbucket_Credential() {}

type CircleCI struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*CircleCI_Token
	Credential    isCircleCI_Credential `protobuf_oneof:"credential"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CircleCI) Reset() {
	*x = CircleCI{}
	mi := &file_sources_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CircleCI) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CircleCI) ProtoMessage() {}

func (x *CircleCI) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CircleCI.ProtoReflect.Descriptor instead.
func (*CircleCI) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{4}
}

func (x *CircleCI) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *CircleCI) GetCredential() isCircleCI_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *CircleCI) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*CircleCI_Token); ok {
			return x.Token
		}
	}
	return ""
}

type isCircleCI_Credential interface {
	isCircleCI_Credential()
}

type CircleCI_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}

func (*CircleCI_Token) isCircleCI_Credential() {}

type TravisCI struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*TravisCI_Token
	Credential    isTravisCI_Credential `protobuf_oneof:"credential"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TravisCI) Reset() {
	*x = TravisCI{}
	mi := &file_sources_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TravisCI) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TravisCI) ProtoMessage() {}

func (x *TravisCI) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TravisCI.ProtoReflect.Descriptor instead.
func (*TravisCI) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{5}
}

func (x *TravisCI) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *TravisCI) GetCredential() isTravisCI_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *TravisCI) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*TravisCI_Token); ok {
			return x.Token
		}
	}
	return ""
}

type isTravisCI_Credential interface {
	isTravisCI_Credential()
}

type TravisCI_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}

func (*TravisCI_Token) isTravisCI_Credential() {}

type Confluence struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Confluence_Unauthenticated
	//	*Confluence_BasicAuth
	//	*Confluence_Token
	Credential            isConfluence_Credential      `protobuf_oneof:"credential"`
	SpacesScope           Confluence_GetAllSpacesScope `protobuf:"varint,5,opt,name=spaces_scope,json=spacesScope,proto3,enum=sources.Confluence_GetAllSpacesScope" json:"spaces_scope,omitempty"`
	InsecureSkipVerifyTls bool                         `protobuf:"varint,6,opt,name=insecure_skip_verify_tls,json=insecureSkipVerifyTls,proto3" json:"insecure_skip_verify_tls,omitempty"`
	Spaces                []string                     `protobuf:"bytes,7,rep,name=spaces,proto3" json:"spaces,omitempty"`
	IgnoreSpaces          []string                     `protobuf:"bytes,8,rep,name=ignore_spaces,json=ignoreSpaces,proto3" json:"ignore_spaces,omitempty"`
	IncludeAttachments    bool                         `protobuf:"varint,9,opt,name=include_attachments,json=includeAttachments,proto3" json:"include_attachments,omitempty"`
	SkipHistory           bool                         `protobuf:"varint,10,opt,name=skip_history,json=skipHistory,proto3" json:"skip_history,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *Confluence) Reset() {
	*x = Confluence{}
	mi := &file_sources_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Confluence) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Confluence) ProtoMessage() {}

func (x *Confluence) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Confluence.ProtoReflect.Descriptor instead.
func (*Confluence) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{6}
}

func (x *Confluence) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *Confluence) GetCredential() isConfluence_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Confluence) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*Confluence_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *Confluence) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*Confluence_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *Confluence) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*Confluence_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *Confluence) GetSpacesScope() Confluence_GetAllSpacesScope {
	if x != nil {
		return x.SpacesScope
	}
	return Confluence_ALL
}

func (x *Confluence) GetInsecureSkipVerifyTls() bool {
	if x != nil {
		return x.InsecureSkipVerifyTls
	}
	return false
}

func (x *Confluence) GetSpaces() []string {
	if x != nil {
		return x.Spaces
	}
	return nil
}

func (x *Confluence) GetIgnoreSpaces() []string {
	if x != nil {
		return x.IgnoreSpaces
	}
	return nil
}

func (x *Confluence) GetIncludeAttachments() bool {
	if x != nil {
		return x.IncludeAttachments
	}
	return false
}

func (x *Confluence) GetSkipHistory() bool {
	if x != nil {
		return x.SkipHistory
	}
	return false
}

type isConfluence_Credential interface {
	isConfluence_Credential()
}

type Confluence_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,2,opt,name=unauthenticated,proto3,oneof"`
}

type Confluence_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,3,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

type Confluence_Token struct {
	Token string `protobuf:"bytes,4,opt,name=token,proto3,oneof"`
}

func (*Confluence_Unauthenticated) isConfluence_Credential() {}

func (*Confluence_BasicAuth) isConfluence_Credential() {}

func (*Confluence_Token) isConfluence_Credential() {}

type Docker struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Docker_Unauthenticated
	//	*Docker_BasicAuth
	//	*Docker_BearerToken
	//	*Docker_DockerKeychain
	Credential    isDocker_Credential `protobuf_oneof:"credential"`
	Images        []string            `protobuf:"bytes,5,rep,name=images,proto3" json:"images,omitempty"`
	ExcludePaths  []string            `protobuf:"bytes,6,rep,name=exclude_paths,json=excludePaths,proto3" json:"exclude_paths,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Docker) Reset() {
	*x = Docker{}
	mi := &file_sources_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Docker) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Docker) ProtoMessage() {}

func (x *Docker) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Docker.ProtoReflect.Descriptor instead.
func (*Docker) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{7}
}

func (x *Docker) GetCredential() isDocker_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Docker) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*Docker_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *Docker) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*Docker_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *Docker) GetBearerToken() string {
	if x != nil {
		if x, ok := x.Credential.(*Docker_BearerToken); ok {
			return x.BearerToken
		}
	}
	return ""
}

func (x *Docker) GetDockerKeychain() bool {
	if x != nil {
		if x, ok := x.Credential.(*Docker_DockerKeychain); ok {
			return x.DockerKeychain
		}
	}
	return false
}

func (x *Docker) GetImages() []string {
	if x != nil {
		return x.Images
	}
	return nil
}

func (x *Docker) GetExcludePaths() []string {
	if x != nil {
		return x.ExcludePaths
	}
	return nil
}

type isDocker_Credential interface {
	isDocker_Credential()
}

type Docker_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,1,opt,name=unauthenticated,proto3,oneof"`
}

type Docker_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,2,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

type Docker_BearerToken struct {
	BearerToken string `protobuf:"bytes,3,opt,name=bearer_token,json=bearerToken,proto3,oneof"`
}

type Docker_DockerKeychain struct {
	DockerKeychain bool `protobuf:"varint,4,opt,name=docker_keychain,json=dockerKeychain,proto3,oneof"`
}

func (*Docker_Unauthenticated) isDocker_Credential() {}

func (*Docker_BasicAuth) isDocker_Credential() {}

func (*Docker_BearerToken) isDocker_Credential() {}

func (*Docker_DockerKeychain) isDocker_Credential() {}

type ECR struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*ECR_AccessKey
	Credential    isECR_Credential `protobuf_oneof:"credential"`
	Registries    []string         `protobuf:"bytes,2,rep,name=registries,proto3" json:"registries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ECR) Reset() {
	*x = ECR{}
	mi := &file_sources_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ECR) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ECR) ProtoMessage() {}

func (x *ECR) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ECR.ProtoReflect.Descriptor instead.
func (*ECR) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{8}
}

func (x *ECR) GetCredential() isECR_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *ECR) GetAccessKey() *credentialspb.KeySecret {
	if x != nil {
		if x, ok := x.Credential.(*ECR_AccessKey); ok {
			return x.AccessKey
		}
	}
	return nil
}

func (x *ECR) GetRegistries() []string {
	if x != nil {
		return x.Registries
	}
	return nil
}

type isECR_Credential interface {
	isECR_Credential()
}

type ECR_AccessKey struct {
	AccessKey *credentialspb.KeySecret `protobuf:"bytes,1,opt,name=access_key,json=accessKey,proto3,oneof"`
}

func (*ECR_AccessKey) isECR_Credential() {}

type Filesystem struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// DEPRECATED: directories is deprecated and can be removed / renamed to
	// paths when we no longer depend on the name in enterprise configs.
	Directories      []string `protobuf:"bytes,1,rep,name=directories,proto3" json:"directories,omitempty"`
	Paths            []string `protobuf:"bytes,2,rep,name=paths,proto3" json:"paths,omitempty"`
	IncludePathsFile string   `protobuf:"bytes,3,opt,name=include_paths_file,json=includePathsFile,proto3" json:"include_paths_file,omitempty"` // path to file containing newline separated list of paths
	ExcludePathsFile string   `protobuf:"bytes,4,opt,name=exclude_paths_file,json=excludePathsFile,proto3" json:"exclude_paths_file,omitempty"` // path to file containing newline separated list of paths
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Filesystem) Reset() {
	*x = Filesystem{}
	mi := &file_sources_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Filesystem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Filesystem) ProtoMessage() {}

func (x *Filesystem) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Filesystem.ProtoReflect.Descriptor instead.
func (*Filesystem) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{9}
}

func (x *Filesystem) GetDirectories() []string {
	if x != nil {
		return x.Directories
	}
	return nil
}

func (x *Filesystem) GetPaths() []string {
	if x != nil {
		return x.Paths
	}
	return nil
}

func (x *Filesystem) GetIncludePathsFile() string {
	if x != nil {
		return x.IncludePathsFile
	}
	return ""
}

func (x *Filesystem) GetExcludePathsFile() string {
	if x != nil {
		return x.ExcludePathsFile
	}
	return ""
}

type GCS struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*GCS_JsonServiceAccount
	//	*GCS_ApiKey
	//	*GCS_Unauthenticated
	//	*GCS_Adc
	//	*GCS_ServiceAccountFile
	//	*GCS_Oauth
	Credential     isGCS_Credential `protobuf_oneof:"credential"`
	ProjectId      string           `protobuf:"bytes,5,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	IncludeBuckets []string         `protobuf:"bytes,6,rep,name=include_buckets,json=includeBuckets,proto3" json:"include_buckets,omitempty"`
	ExcludeBuckets []string         `protobuf:"bytes,7,rep,name=exclude_buckets,json=excludeBuckets,proto3" json:"exclude_buckets,omitempty"`
	IncludeObjects []string         `protobuf:"bytes,8,rep,name=include_objects,json=includeObjects,proto3" json:"include_objects,omitempty"`
	ExcludeObjects []string         `protobuf:"bytes,9,rep,name=exclude_objects,json=excludeObjects,proto3" json:"exclude_objects,omitempty"`
	MaxObjectSize  int64            `protobuf:"varint,10,opt,name=max_object_size,json=maxObjectSize,proto3" json:"max_object_size,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GCS) Reset() {
	*x = GCS{}
	mi := &file_sources_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GCS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GCS) ProtoMessage() {}

func (x *GCS) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GCS.ProtoReflect.Descriptor instead.
func (*GCS) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{10}
}

func (x *GCS) GetCredential() isGCS_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *GCS) GetJsonServiceAccount() string {
	if x != nil {
		if x, ok := x.Credential.(*GCS_JsonServiceAccount); ok {
			return x.JsonServiceAccount
		}
	}
	return ""
}

func (x *GCS) GetApiKey() string {
	if x != nil {
		if x, ok := x.Credential.(*GCS_ApiKey); ok {
			return x.ApiKey
		}
	}
	return ""
}

func (x *GCS) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*GCS_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *GCS) GetAdc() *credentialspb.CloudEnvironment {
	if x != nil {
		if x, ok := x.Credential.(*GCS_Adc); ok {
			return x.Adc
		}
	}
	return nil
}

func (x *GCS) GetServiceAccountFile() string {
	if x != nil {
		if x, ok := x.Credential.(*GCS_ServiceAccountFile); ok {
			return x.ServiceAccountFile
		}
	}
	return ""
}

func (x *GCS) GetOauth() *credentialspb.Oauth2 {
	if x != nil {
		if x, ok := x.Credential.(*GCS_Oauth); ok {
			return x.Oauth
		}
	}
	return nil
}

func (x *GCS) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *GCS) GetIncludeBuckets() []string {
	if x != nil {
		return x.IncludeBuckets
	}
	return nil
}

func (x *GCS) GetExcludeBuckets() []string {
	if x != nil {
		return x.ExcludeBuckets
	}
	return nil
}

func (x *GCS) GetIncludeObjects() []string {
	if x != nil {
		return x.IncludeObjects
	}
	return nil
}

func (x *GCS) GetExcludeObjects() []string {
	if x != nil {
		return x.ExcludeObjects
	}
	return nil
}

func (x *GCS) GetMaxObjectSize() int64 {
	if x != nil {
		return x.MaxObjectSize
	}
	return 0
}

type isGCS_Credential interface {
	isGCS_Credential()
}

type GCS_JsonServiceAccount struct {
	JsonServiceAccount string `protobuf:"bytes,1,opt,name=json_service_account,json=jsonServiceAccount,proto3,oneof"`
}

type GCS_ApiKey struct {
	ApiKey string `protobuf:"bytes,2,opt,name=api_key,json=apiKey,proto3,oneof"`
}

type GCS_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,3,opt,name=unauthenticated,proto3,oneof"`
}

type GCS_Adc struct {
	Adc *credentialspb.CloudEnvironment `protobuf:"bytes,4,opt,name=adc,proto3,oneof"`
}

type GCS_ServiceAccountFile struct {
	ServiceAccountFile string `protobuf:"bytes,11,opt,name=service_account_file,json=serviceAccountFile,proto3,oneof"`
}

type GCS_Oauth struct {
	Oauth *credentialspb.Oauth2 `protobuf:"bytes,12,opt,name=oauth,proto3,oneof"`
}

func (*GCS_JsonServiceAccount) isGCS_Credential() {}

func (*GCS_ApiKey) isGCS_Credential() {}

func (*GCS_Unauthenticated) isGCS_Credential() {}

func (*GCS_Adc) isGCS_Credential() {}

func (*GCS_ServiceAccountFile) isGCS_Credential() {}

func (*GCS_Oauth) isGCS_Credential() {}

type Git struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Git_BasicAuth
	//	*Git_Unauthenticated
	//	*Git_SshAuth
	Credential       isGit_Credential `protobuf_oneof:"credential"`
	Directories      []string         `protobuf:"bytes,3,rep,name=directories,proto3" json:"directories,omitempty"`
	Repositories     []string         `protobuf:"bytes,4,rep,name=repositories,proto3" json:"repositories,omitempty"`
	Head             string           `protobuf:"bytes,6,opt,name=head,proto3" json:"head,omitempty"`
	Base             string           `protobuf:"bytes,7,opt,name=base,proto3" json:"base,omitempty"`
	Bare             bool             `protobuf:"varint,8,opt,name=bare,proto3" json:"bare,omitempty"`
	IncludePathsFile string           `protobuf:"bytes,9,opt,name=include_paths_file,json=includePathsFile,proto3" json:"include_paths_file,omitempty"`  // path to file containing newline separated list of paths
	ExcludePathsFile string           `protobuf:"bytes,10,opt,name=exclude_paths_file,json=excludePathsFile,proto3" json:"exclude_paths_file,omitempty"` // path to file containing newline separated list of paths
	ExcludeGlobs     string           `protobuf:"bytes,11,opt,name=exclude_globs,json=excludeGlobs,proto3" json:"exclude_globs,omitempty"`               // comma separated list of globs
	MaxDepth         int64            `protobuf:"varint,12,opt,name=max_depth,json=maxDepth,proto3" json:"max_depth,omitempty"`
	// This field is generally used by the CLI or within CI/CD systems to specify a single repository,
	// whereas the repositories field is used by the enterprise config to specify multiple repositories.
	// Passing a single repository via the uri field also allows for additional options to be specified
	// like head, base, bare, etc.
	Uri           string `protobuf:"bytes,13,opt,name=uri,proto3" json:"uri,omitempty"` // repository URL. https://, file://, or ssh://
	SkipBinaries  bool   `protobuf:"varint,14,opt,name=skip_binaries,json=skipBinaries,proto3" json:"skip_binaries,omitempty"`
	SkipArchives  bool   `protobuf:"varint,15,opt,name=skip_archives,json=skipArchives,proto3" json:"skip_archives,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Git) Reset() {
	*x = Git{}
	mi := &file_sources_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Git) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Git) ProtoMessage() {}

func (x *Git) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Git.ProtoReflect.Descriptor instead.
func (*Git) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{11}
}

func (x *Git) GetCredential() isGit_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Git) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*Git_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *Git) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*Git_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *Git) GetSshAuth() *credentialspb.SSHAuth {
	if x != nil {
		if x, ok := x.Credential.(*Git_SshAuth); ok {
			return x.SshAuth
		}
	}
	return nil
}

func (x *Git) GetDirectories() []string {
	if x != nil {
		return x.Directories
	}
	return nil
}

func (x *Git) GetRepositories() []string {
	if x != nil {
		return x.Repositories
	}
	return nil
}

func (x *Git) GetHead() string {
	if x != nil {
		return x.Head
	}
	return ""
}

func (x *Git) GetBase() string {
	if x != nil {
		return x.Base
	}
	return ""
}

func (x *Git) GetBare() bool {
	if x != nil {
		return x.Bare
	}
	return false
}

func (x *Git) GetIncludePathsFile() string {
	if x != nil {
		return x.IncludePathsFile
	}
	return ""
}

func (x *Git) GetExcludePathsFile() string {
	if x != nil {
		return x.ExcludePathsFile
	}
	return ""
}

func (x *Git) GetExcludeGlobs() string {
	if x != nil {
		return x.ExcludeGlobs
	}
	return ""
}

func (x *Git) GetMaxDepth() int64 {
	if x != nil {
		return x.MaxDepth
	}
	return 0
}

func (x *Git) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

func (x *Git) GetSkipBinaries() bool {
	if x != nil {
		return x.SkipBinaries
	}
	return false
}

func (x *Git) GetSkipArchives() bool {
	if x != nil {
		return x.SkipArchives
	}
	return false
}

type isGit_Credential interface {
	isGit_Credential()
}

type Git_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,1,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

type Git_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,2,opt,name=unauthenticated,proto3,oneof"`
}

type Git_SshAuth struct {
	SshAuth *credentialspb.SSHAuth `protobuf:"bytes,5,opt,name=ssh_auth,json=sshAuth,proto3,oneof"`
}

func (*Git_BasicAuth) isGit_Credential() {}

func (*Git_Unauthenticated) isGit_Credential() {}

func (*Git_SshAuth) isGit_Credential() {}

type GitLab struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*GitLab_Token
	//	*GitLab_Oauth
	//	*GitLab_BasicAuth
	Credential                      isGitLab_Credential `protobuf_oneof:"credential"`
	Repositories                    []string            `protobuf:"bytes,5,rep,name=repositories,proto3" json:"repositories,omitempty"`
	IgnoreRepos                     []string            `protobuf:"bytes,6,rep,name=ignore_repos,json=ignoreRepos,proto3" json:"ignore_repos,omitempty"`
	SkipBinaries                    bool                `protobuf:"varint,7,opt,name=skip_binaries,json=skipBinaries,proto3" json:"skip_binaries,omitempty"`
	SkipArchives                    bool                `protobuf:"varint,8,opt,name=skip_archives,json=skipArchives,proto3" json:"skip_archives,omitempty"`
	IncludeRepos                    []string            `protobuf:"bytes,9,rep,name=include_repos,json=includeRepos,proto3" json:"include_repos,omitempty"`
	ExcludeProjectsSharedIntoGroups bool                `protobuf:"varint,10,opt,name=exclude_projects_shared_into_groups,json=excludeProjectsSharedIntoGroups,proto3" json:"exclude_projects_shared_into_groups,omitempty"`
	RemoveAuthInUrl                 bool                `protobuf:"varint,11,opt,name=remove_auth_in_url,json=removeAuthInUrl,proto3" json:"remove_auth_in_url,omitempty"`
	unknownFields                   protoimpl.UnknownFields
	sizeCache                       protoimpl.SizeCache
}

func (x *GitLab) Reset() {
	*x = GitLab{}
	mi := &file_sources_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitLab) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitLab) ProtoMessage() {}

func (x *GitLab) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitLab.ProtoReflect.Descriptor instead.
func (*GitLab) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{12}
}

func (x *GitLab) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *GitLab) GetCredential() isGitLab_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *GitLab) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*GitLab_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *GitLab) GetOauth() *credentialspb.Oauth2 {
	if x != nil {
		if x, ok := x.Credential.(*GitLab_Oauth); ok {
			return x.Oauth
		}
	}
	return nil
}

func (x *GitLab) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*GitLab_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *GitLab) GetRepositories() []string {
	if x != nil {
		return x.Repositories
	}
	return nil
}

func (x *GitLab) GetIgnoreRepos() []string {
	if x != nil {
		return x.IgnoreRepos
	}
	return nil
}

func (x *GitLab) GetSkipBinaries() bool {
	if x != nil {
		return x.SkipBinaries
	}
	return false
}

func (x *GitLab) GetSkipArchives() bool {
	if x != nil {
		return x.SkipArchives
	}
	return false
}

func (x *GitLab) GetIncludeRepos() []string {
	if x != nil {
		return x.IncludeRepos
	}
	return nil
}

func (x *GitLab) GetExcludeProjectsSharedIntoGroups() bool {
	if x != nil {
		return x.ExcludeProjectsSharedIntoGroups
	}
	return false
}

func (x *GitLab) GetRemoveAuthInUrl() bool {
	if x != nil {
		return x.RemoveAuthInUrl
	}
	return false
}

type isGitLab_Credential interface {
	isGitLab_Credential()
}

type GitLab_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}

type GitLab_Oauth struct {
	Oauth *credentialspb.Oauth2 `protobuf:"bytes,3,opt,name=oauth,proto3,oneof"`
}

type GitLab_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,4,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

func (*GitLab_Token) isGitLab_Credential() {}

func (*GitLab_Oauth) isGitLab_Credential() {}

func (*GitLab_BasicAuth) isGitLab_Credential() {}

type GitHub struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*GitHub_GithubApp
	//	*GitHub_Token
	//	*GitHub_Unauthenticated
	//	*GitHub_BasicAuth
	Credential                 isGitHub_Credential `protobuf_oneof:"credential"`
	Repositories               []string            `protobuf:"bytes,5,rep,name=repositories,proto3" json:"repositories,omitempty"`
	Organizations              []string            `protobuf:"bytes,6,rep,name=organizations,proto3" json:"organizations,omitempty"`
	ScanUsers                  bool                `protobuf:"varint,7,opt,name=scanUsers,proto3" json:"scanUsers,omitempty"`
	IncludeForks               bool                `protobuf:"varint,8,opt,name=includeForks,proto3" json:"includeForks,omitempty"`
	Head                       string              `protobuf:"bytes,9,opt,name=head,proto3" json:"head,omitempty"`
	Base                       string              `protobuf:"bytes,10,opt,name=base,proto3" json:"base,omitempty"`
	IgnoreRepos                []string            `protobuf:"bytes,11,rep,name=ignore_repos,json=ignoreRepos,proto3" json:"ignore_repos,omitempty"`
	IncludeRepos               []string            `protobuf:"bytes,12,rep,name=include_repos,json=includeRepos,proto3" json:"include_repos,omitempty"`
	IncludePullRequestComments bool                `protobuf:"varint,14,opt,name=include_pull_request_comments,json=includePullRequestComments,proto3" json:"include_pull_request_comments,omitempty"`
	IncludeIssueComments       bool                `protobuf:"varint,15,opt,name=include_issue_comments,json=includeIssueComments,proto3" json:"include_issue_comments,omitempty"`
	IncludeGistComments        bool                `protobuf:"varint,16,opt,name=include_gist_comments,json=includeGistComments,proto3" json:"include_gist_comments,omitempty"`
	SkipBinaries               bool                `protobuf:"varint,17,opt,name=skip_binaries,json=skipBinaries,proto3" json:"skip_binaries,omitempty"`
	SkipArchives               bool                `protobuf:"varint,18,opt,name=skip_archives,json=skipArchives,proto3" json:"skip_archives,omitempty"`
	IncludeWikis               bool                `protobuf:"varint,19,opt,name=include_wikis,json=includeWikis,proto3" json:"include_wikis,omitempty"`
	CommentsTimeframeDays      uint32              `protobuf:"varint,20,opt,name=comments_timeframe_days,json=commentsTimeframeDays,proto3" json:"comments_timeframe_days,omitempty"`
	RemoveAuthInUrl            bool                `protobuf:"varint,21,opt,name=remove_auth_in_url,json=removeAuthInUrl,proto3" json:"remove_auth_in_url,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *GitHub) Reset() {
	*x = GitHub{}
	mi := &file_sources_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitHub) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitHub) ProtoMessage() {}

func (x *GitHub) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitHub.ProtoReflect.Descriptor instead.
func (*GitHub) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{13}
}

func (x *GitHub) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *GitHub) GetCredential() isGitHub_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *GitHub) GetGithubApp() *credentialspb.GitHubApp {
	if x != nil {
		if x, ok := x.Credential.(*GitHub_GithubApp); ok {
			return x.GithubApp
		}
	}
	return nil
}

func (x *GitHub) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*GitHub_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *GitHub) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*GitHub_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *GitHub) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*GitHub_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *GitHub) GetRepositories() []string {
	if x != nil {
		return x.Repositories
	}
	return nil
}

func (x *GitHub) GetOrganizations() []string {
	if x != nil {
		return x.Organizations
	}
	return nil
}

func (x *GitHub) GetScanUsers() bool {
	if x != nil {
		return x.ScanUsers
	}
	return false
}

func (x *GitHub) GetIncludeForks() bool {
	if x != nil {
		return x.IncludeForks
	}
	return false
}

func (x *GitHub) GetHead() string {
	if x != nil {
		return x.Head
	}
	return ""
}

func (x *GitHub) GetBase() string {
	if x != nil {
		return x.Base
	}
	return ""
}

func (x *GitHub) GetIgnoreRepos() []string {
	if x != nil {
		return x.IgnoreRepos
	}
	return nil
}

func (x *GitHub) GetIncludeRepos() []string {
	if x != nil {
		return x.IncludeRepos
	}
	return nil
}

func (x *GitHub) GetIncludePullRequestComments() bool {
	if x != nil {
		return x.IncludePullRequestComments
	}
	return false
}

func (x *GitHub) GetIncludeIssueComments() bool {
	if x != nil {
		return x.IncludeIssueComments
	}
	return false
}

func (x *GitHub) GetIncludeGistComments() bool {
	if x != nil {
		return x.IncludeGistComments
	}
	return false
}

func (x *GitHub) GetSkipBinaries() bool {
	if x != nil {
		return x.SkipBinaries
	}
	return false
}

func (x *GitHub) GetSkipArchives() bool {
	if x != nil {
		return x.SkipArchives
	}
	return false
}

func (x *GitHub) GetIncludeWikis() bool {
	if x != nil {
		return x.IncludeWikis
	}
	return false
}

func (x *GitHub) GetCommentsTimeframeDays() uint32 {
	if x != nil {
		return x.CommentsTimeframeDays
	}
	return 0
}

func (x *GitHub) GetRemoveAuthInUrl() bool {
	if x != nil {
		return x.RemoveAuthInUrl
	}
	return false
}

type isGitHub_Credential interface {
	isGitHub_Credential()
}

type GitHub_GithubApp struct {
	GithubApp *credentialspb.GitHubApp `protobuf:"bytes,2,opt,name=github_app,json=githubApp,proto3,oneof"`
}

type GitHub_Token struct {
	Token string `protobuf:"bytes,3,opt,name=token,proto3,oneof"`
}

type GitHub_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,4,opt,name=unauthenticated,proto3,oneof"`
}

type GitHub_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,13,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

func (*GitHub_GithubApp) isGitHub_Credential() {}

func (*GitHub_Token) isGitHub_Credential() {}

func (*GitHub_Unauthenticated) isGitHub_Credential() {}

func (*GitHub_BasicAuth) isGitHub_Credential() {}

type GitHubExperimental struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	Repository string                 `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*GitHubExperimental_Token
	Credential         isGitHubExperimental_Credential `protobuf_oneof:"credential"`
	ObjectDiscovery    bool                            `protobuf:"varint,3,opt,name=object_discovery,json=objectDiscovery,proto3" json:"object_discovery,omitempty"`
	CollisionThreshold int64                           `protobuf:"varint,4,opt,name=collision_threshold,json=collisionThreshold,proto3" json:"collision_threshold,omitempty"`
	DeleteCachedData   bool                            `protobuf:"varint,5,opt,name=delete_cached_data,json=deleteCachedData,proto3" json:"delete_cached_data,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *GitHubExperimental) Reset() {
	*x = GitHubExperimental{}
	mi := &file_sources_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitHubExperimental) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitHubExperimental) ProtoMessage() {}

func (x *GitHubExperimental) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitHubExperimental.ProtoReflect.Descriptor instead.
func (*GitHubExperimental) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{14}
}

func (x *GitHubExperimental) GetRepository() string {
	if x != nil {
		return x.Repository
	}
	return ""
}

func (x *GitHubExperimental) GetCredential() isGitHubExperimental_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *GitHubExperimental) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*GitHubExperimental_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *GitHubExperimental) GetObjectDiscovery() bool {
	if x != nil {
		return x.ObjectDiscovery
	}
	return false
}

func (x *GitHubExperimental) GetCollisionThreshold() int64 {
	if x != nil {
		return x.CollisionThreshold
	}
	return 0
}

func (x *GitHubExperimental) GetDeleteCachedData() bool {
	if x != nil {
		return x.DeleteCachedData
	}
	return false
}

type isGitHubExperimental_Credential interface {
	isGitHubExperimental_Credential()
}

type GitHubExperimental_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}

func (*GitHubExperimental_Token) isGitHubExperimental_Credential() {}

type GitHubRealtime struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ListenerPort  uint32                 `protobuf:"varint,1,opt,name=listener_port,json=listenerPort,proto3" json:"listener_port,omitempty"`
	WebhookSecret string                 `protobuf:"bytes,2,opt,name=webhook_secret,json=webhookSecret,proto3" json:"webhook_secret,omitempty"`
	Endpoint      string                 `protobuf:"bytes,3,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*GitHubRealtime_GithubApp
	//	*GitHubRealtime_Token
	//	*GitHubRealtime_Unauthenticated
	//	*GitHubRealtime_BasicAuth
	Credential    isGitHubRealtime_Credential `protobuf_oneof:"credential"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GitHubRealtime) Reset() {
	*x = GitHubRealtime{}
	mi := &file_sources_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GitHubRealtime) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GitHubRealtime) ProtoMessage() {}

func (x *GitHubRealtime) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GitHubRealtime.ProtoReflect.Descriptor instead.
func (*GitHubRealtime) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{15}
}

func (x *GitHubRealtime) GetListenerPort() uint32 {
	if x != nil {
		return x.ListenerPort
	}
	return 0
}

func (x *GitHubRealtime) GetWebhookSecret() string {
	if x != nil {
		return x.WebhookSecret
	}
	return ""
}

func (x *GitHubRealtime) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *GitHubRealtime) GetCredential() isGitHubRealtime_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *GitHubRealtime) GetGithubApp() *credentialspb.GitHubApp {
	if x != nil {
		if x, ok := x.Credential.(*GitHubRealtime_GithubApp); ok {
			return x.GithubApp
		}
	}
	return nil
}

func (x *GitHubRealtime) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*GitHubRealtime_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *GitHubRealtime) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*GitHubRealtime_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *GitHubRealtime) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*GitHubRealtime_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

type isGitHubRealtime_Credential interface {
	isGitHubRealtime_Credential()
}

type GitHubRealtime_GithubApp struct {
	GithubApp *credentialspb.GitHubApp `protobuf:"bytes,4,opt,name=github_app,json=githubApp,proto3,oneof"`
}

type GitHubRealtime_Token struct {
	Token string `protobuf:"bytes,5,opt,name=token,proto3,oneof"`
}

type GitHubRealtime_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,6,opt,name=unauthenticated,proto3,oneof"`
}

type GitHubRealtime_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,7,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

func (*GitHubRealtime_GithubApp) isGitHubRealtime_Credential() {}

func (*GitHubRealtime_Token) isGitHubRealtime_Credential() {}

func (*GitHubRealtime_Unauthenticated) isGitHubRealtime_Credential() {}

func (*GitHubRealtime_BasicAuth) isGitHubRealtime_Credential() {}

type GoogleDrive struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*GoogleDrive_RefreshToken
	Credential    isGoogleDrive_Credential `protobuf_oneof:"credential"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GoogleDrive) Reset() {
	*x = GoogleDrive{}
	mi := &file_sources_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GoogleDrive) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GoogleDrive) ProtoMessage() {}

func (x *GoogleDrive) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GoogleDrive.ProtoReflect.Descriptor instead.
func (*GoogleDrive) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{16}
}

func (x *GoogleDrive) GetCredential() isGoogleDrive_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *GoogleDrive) GetRefreshToken() string {
	if x != nil {
		if x, ok := x.Credential.(*GoogleDrive_RefreshToken); ok {
			return x.RefreshToken
		}
	}
	return ""
}

type isGoogleDrive_Credential interface {
	isGoogleDrive_Credential()
}

type GoogleDrive_RefreshToken struct {
	RefreshToken string `protobuf:"bytes,1,opt,name=refresh_token,json=refreshToken,proto3,oneof"`
}

func (*GoogleDrive_RefreshToken) isGoogleDrive_Credential() {}

type Huggingface struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Huggingface_Token
	//	*Huggingface_Unauthenticated
	Credential         isHuggingface_Credential `protobuf_oneof:"credential"`
	Models             []string                 `protobuf:"bytes,4,rep,name=models,proto3" json:"models,omitempty"`
	Spaces             []string                 `protobuf:"bytes,5,rep,name=spaces,proto3" json:"spaces,omitempty"`
	Datasets           []string                 `protobuf:"bytes,12,rep,name=datasets,proto3" json:"datasets,omitempty"`
	Organizations      []string                 `protobuf:"bytes,6,rep,name=organizations,proto3" json:"organizations,omitempty"`
	Users              []string                 `protobuf:"bytes,15,rep,name=users,proto3" json:"users,omitempty"`
	IgnoreModels       []string                 `protobuf:"bytes,7,rep,name=ignore_models,json=ignoreModels,proto3" json:"ignore_models,omitempty"`
	IncludeModels      []string                 `protobuf:"bytes,8,rep,name=include_models,json=includeModels,proto3" json:"include_models,omitempty"`
	IgnoreSpaces       []string                 `protobuf:"bytes,9,rep,name=ignore_spaces,json=ignoreSpaces,proto3" json:"ignore_spaces,omitempty"`
	IncludeSpaces      []string                 `protobuf:"bytes,10,rep,name=include_spaces,json=includeSpaces,proto3" json:"include_spaces,omitempty"`
	IgnoreDatasets     []string                 `protobuf:"bytes,13,rep,name=ignore_datasets,json=ignoreDatasets,proto3" json:"ignore_datasets,omitempty"`
	IncludeDatasets    []string                 `protobuf:"bytes,14,rep,name=include_datasets,json=includeDatasets,proto3" json:"include_datasets,omitempty"`
	SkipAllModels      bool                     `protobuf:"varint,16,opt,name=skip_all_models,json=skipAllModels,proto3" json:"skip_all_models,omitempty"`
	SkipAllSpaces      bool                     `protobuf:"varint,17,opt,name=skip_all_spaces,json=skipAllSpaces,proto3" json:"skip_all_spaces,omitempty"`
	SkipAllDatasets    bool                     `protobuf:"varint,18,opt,name=skip_all_datasets,json=skipAllDatasets,proto3" json:"skip_all_datasets,omitempty"`
	IncludeDiscussions bool                     `protobuf:"varint,11,opt,name=include_discussions,json=includeDiscussions,proto3" json:"include_discussions,omitempty"`
	IncludePrs         bool                     `protobuf:"varint,19,opt,name=include_prs,json=includePrs,proto3" json:"include_prs,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *Huggingface) Reset() {
	*x = Huggingface{}
	mi := &file_sources_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Huggingface) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Huggingface) ProtoMessage() {}

func (x *Huggingface) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Huggingface.ProtoReflect.Descriptor instead.
func (*Huggingface) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{17}
}

func (x *Huggingface) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *Huggingface) GetCredential() isHuggingface_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Huggingface) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*Huggingface_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *Huggingface) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*Huggingface_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *Huggingface) GetModels() []string {
	if x != nil {
		return x.Models
	}
	return nil
}

func (x *Huggingface) GetSpaces() []string {
	if x != nil {
		return x.Spaces
	}
	return nil
}

func (x *Huggingface) GetDatasets() []string {
	if x != nil {
		return x.Datasets
	}
	return nil
}

func (x *Huggingface) GetOrganizations() []string {
	if x != nil {
		return x.Organizations
	}
	return nil
}

func (x *Huggingface) GetUsers() []string {
	if x != nil {
		return x.Users
	}
	return nil
}

func (x *Huggingface) GetIgnoreModels() []string {
	if x != nil {
		return x.IgnoreModels
	}
	return nil
}

func (x *Huggingface) GetIncludeModels() []string {
	if x != nil {
		return x.IncludeModels
	}
	return nil
}

func (x *Huggingface) GetIgnoreSpaces() []string {
	if x != nil {
		return x.IgnoreSpaces
	}
	return nil
}

func (x *Huggingface) GetIncludeSpaces() []string {
	if x != nil {
		return x.IncludeSpaces
	}
	return nil
}

func (x *Huggingface) GetIgnoreDatasets() []string {
	if x != nil {
		return x.IgnoreDatasets
	}
	return nil
}

func (x *Huggingface) GetIncludeDatasets() []string {
	if x != nil {
		return x.IncludeDatasets
	}
	return nil
}

func (x *Huggingface) GetSkipAllModels() bool {
	if x != nil {
		return x.SkipAllModels
	}
	return false
}

func (x *Huggingface) GetSkipAllSpaces() bool {
	if x != nil {
		return x.SkipAllSpaces
	}
	return false
}

func (x *Huggingface) GetSkipAllDatasets() bool {
	if x != nil {
		return x.SkipAllDatasets
	}
	return false
}

func (x *Huggingface) GetIncludeDiscussions() bool {
	if x != nil {
		return x.IncludeDiscussions
	}
	return false
}

func (x *Huggingface) GetIncludePrs() bool {
	if x != nil {
		return x.IncludePrs
	}
	return false
}

type isHuggingface_Credential interface {
	isHuggingface_Credential()
}

type Huggingface_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}

type Huggingface_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,3,opt,name=unauthenticated,proto3,oneof"`
}

func (*Huggingface_Token) isHuggingface_Credential() {}

func (*Huggingface_Unauthenticated) isHuggingface_Credential() {}

type JIRA struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*JIRA_BasicAuth
	//	*JIRA_Unauthenticated
	//	*JIRA_Oauth
	//	*JIRA_Token
	Credential            isJIRA_Credential `protobuf_oneof:"credential"`
	Projects              []string          `protobuf:"bytes,5,rep,name=projects,proto3" json:"projects,omitempty"`
	IgnoreProjects        []string          `protobuf:"bytes,7,rep,name=ignore_projects,json=ignoreProjects,proto3" json:"ignore_projects,omitempty"`
	InsecureSkipVerifyTls bool              `protobuf:"varint,8,opt,name=insecure_skip_verify_tls,json=insecureSkipVerifyTls,proto3" json:"insecure_skip_verify_tls,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *JIRA) Reset() {
	*x = JIRA{}
	mi := &file_sources_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JIRA) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JIRA) ProtoMessage() {}

func (x *JIRA) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JIRA.ProtoReflect.Descriptor instead.
func (*JIRA) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{18}
}

func (x *JIRA) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *JIRA) GetCredential() isJIRA_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *JIRA) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*JIRA_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *JIRA) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*JIRA_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *JIRA) GetOauth() *credentialspb.Oauth2 {
	if x != nil {
		if x, ok := x.Credential.(*JIRA_Oauth); ok {
			return x.Oauth
		}
	}
	return nil
}

func (x *JIRA) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*JIRA_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *JIRA) GetProjects() []string {
	if x != nil {
		return x.Projects
	}
	return nil
}

func (x *JIRA) GetIgnoreProjects() []string {
	if x != nil {
		return x.IgnoreProjects
	}
	return nil
}

func (x *JIRA) GetInsecureSkipVerifyTls() bool {
	if x != nil {
		return x.InsecureSkipVerifyTls
	}
	return false
}

type isJIRA_Credential interface {
	isJIRA_Credential()
}

type JIRA_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,2,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

type JIRA_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,3,opt,name=unauthenticated,proto3,oneof"`
}

type JIRA_Oauth struct {
	Oauth *credentialspb.Oauth2 `protobuf:"bytes,4,opt,name=oauth,proto3,oneof"`
}

type JIRA_Token struct {
	Token string `protobuf:"bytes,6,opt,name=token,proto3,oneof"`
}

func (*JIRA_BasicAuth) isJIRA_Credential() {}

func (*JIRA_Unauthenticated) isJIRA_Credential() {}

func (*JIRA_Oauth) isJIRA_Credential() {}

func (*JIRA_Token) isJIRA_Credential() {}

type NPMUnauthenticatedPackage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*NPMUnauthenticatedPackage_Unauthenticated
	Credential    isNPMUnauthenticatedPackage_Credential `protobuf_oneof:"credential"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NPMUnauthenticatedPackage) Reset() {
	*x = NPMUnauthenticatedPackage{}
	mi := &file_sources_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NPMUnauthenticatedPackage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NPMUnauthenticatedPackage) ProtoMessage() {}

func (x *NPMUnauthenticatedPackage) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NPMUnauthenticatedPackage.ProtoReflect.Descriptor instead.
func (*NPMUnauthenticatedPackage) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{19}
}

func (x *NPMUnauthenticatedPackage) GetCredential() isNPMUnauthenticatedPackage_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *NPMUnauthenticatedPackage) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*NPMUnauthenticatedPackage_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

type isNPMUnauthenticatedPackage_Credential interface {
	isNPMUnauthenticatedPackage_Credential()
}

type NPMUnauthenticatedPackage_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,1,opt,name=unauthenticated,proto3,oneof"`
}

func (*NPMUnauthenticatedPackage_Unauthenticated) isNPMUnauthenticatedPackage_Credential() {}

type PyPIUnauthenticatedPackage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*PyPIUnauthenticatedPackage_Unauthenticated
	Credential    isPyPIUnauthenticatedPackage_Credential `protobuf_oneof:"credential"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PyPIUnauthenticatedPackage) Reset() {
	*x = PyPIUnauthenticatedPackage{}
	mi := &file_sources_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PyPIUnauthenticatedPackage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PyPIUnauthenticatedPackage) ProtoMessage() {}

func (x *PyPIUnauthenticatedPackage) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PyPIUnauthenticatedPackage.ProtoReflect.Descriptor instead.
func (*PyPIUnauthenticatedPackage) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{20}
}

func (x *PyPIUnauthenticatedPackage) GetCredential() isPyPIUnauthenticatedPackage_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *PyPIUnauthenticatedPackage) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*PyPIUnauthenticatedPackage_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

type isPyPIUnauthenticatedPackage_Credential interface {
	isPyPIUnauthenticatedPackage_Credential()
}

type PyPIUnauthenticatedPackage_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,1,opt,name=unauthenticated,proto3,oneof"`
}

func (*PyPIUnauthenticatedPackage_Unauthenticated) isPyPIUnauthenticatedPackage_Credential() {}

type S3 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*S3_AccessKey
	//	*S3_Unauthenticated
	//	*S3_CloudEnvironment
	//	*S3_SessionToken
	Credential    isS3_Credential `protobuf_oneof:"credential"`
	Buckets       []string        `protobuf:"bytes,3,rep,name=buckets,proto3" json:"buckets,omitempty"`
	MaxObjectSize int64           `protobuf:"varint,6,opt,name=max_object_size,json=maxObjectSize,proto3" json:"max_object_size,omitempty"`
	Roles         []string        `protobuf:"bytes,7,rep,name=roles,proto3" json:"roles,omitempty"`
	IgnoreBuckets []string        `protobuf:"bytes,8,rep,name=ignore_buckets,json=ignoreBuckets,proto3" json:"ignore_buckets,omitempty"`
	// Deprecated: Marked as deprecated in sources.proto.
	EnableResumption bool `protobuf:"varint,9,opt,name=enable_resumption,json=enableResumption,proto3" json:"enable_resumption,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *S3) Reset() {
	*x = S3{}
	mi := &file_sources_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *S3) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*S3) ProtoMessage() {}

func (x *S3) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use S3.ProtoReflect.Descriptor instead.
func (*S3) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{21}
}

func (x *S3) GetCredential() isS3_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *S3) GetAccessKey() *credentialspb.KeySecret {
	if x != nil {
		if x, ok := x.Credential.(*S3_AccessKey); ok {
			return x.AccessKey
		}
	}
	return nil
}

func (x *S3) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*S3_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *S3) GetCloudEnvironment() *credentialspb.CloudEnvironment {
	if x != nil {
		if x, ok := x.Credential.(*S3_CloudEnvironment); ok {
			return x.CloudEnvironment
		}
	}
	return nil
}

func (x *S3) GetSessionToken() *credentialspb.AWSSessionTokenSecret {
	if x != nil {
		if x, ok := x.Credential.(*S3_SessionToken); ok {
			return x.SessionToken
		}
	}
	return nil
}

func (x *S3) GetBuckets() []string {
	if x != nil {
		return x.Buckets
	}
	return nil
}

func (x *S3) GetMaxObjectSize() int64 {
	if x != nil {
		return x.MaxObjectSize
	}
	return 0
}

func (x *S3) GetRoles() []string {
	if x != nil {
		return x.Roles
	}
	return nil
}

func (x *S3) GetIgnoreBuckets() []string {
	if x != nil {
		return x.IgnoreBuckets
	}
	return nil
}

// Deprecated: Marked as deprecated in sources.proto.
func (x *S3) GetEnableResumption() bool {
	if x != nil {
		return x.EnableResumption
	}
	return false
}

type isS3_Credential interface {
	isS3_Credential()
}

type S3_AccessKey struct {
	AccessKey *credentialspb.KeySecret `protobuf:"bytes,1,opt,name=access_key,json=accessKey,proto3,oneof"`
}

type S3_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,2,opt,name=unauthenticated,proto3,oneof"`
}

type S3_CloudEnvironment struct {
	CloudEnvironment *credentialspb.CloudEnvironment `protobuf:"bytes,4,opt,name=cloud_environment,json=cloudEnvironment,proto3,oneof"`
}

type S3_SessionToken struct {
	SessionToken *credentialspb.AWSSessionTokenSecret `protobuf:"bytes,5,opt,name=session_token,json=sessionToken,proto3,oneof"`
}

func (*S3_AccessKey) isS3_Credential() {}

func (*S3_Unauthenticated) isS3_Credential() {}

func (*S3_CloudEnvironment) isS3_Credential() {}

func (*S3_SessionToken) isS3_Credential() {}

type Slack struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Slack_Token
	//	*Slack_Tokens
	Credential    isSlack_Credential `protobuf_oneof:"credential"`
	Channels      []string           `protobuf:"bytes,3,rep,name=channels,proto3" json:"channels,omitempty"`
	IgnoreList    []string           `protobuf:"bytes,4,rep,name=ignore_list,json=ignoreList,proto3" json:"ignore_list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Slack) Reset() {
	*x = Slack{}
	mi := &file_sources_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Slack) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Slack) ProtoMessage() {}

func (x *Slack) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Slack.ProtoReflect.Descriptor instead.
func (*Slack) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{22}
}

func (x *Slack) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *Slack) GetCredential() isSlack_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Slack) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*Slack_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *Slack) GetTokens() *credentialspb.SlackTokens {
	if x != nil {
		if x, ok := x.Credential.(*Slack_Tokens); ok {
			return x.Tokens
		}
	}
	return nil
}

func (x *Slack) GetChannels() []string {
	if x != nil {
		return x.Channels
	}
	return nil
}

func (x *Slack) GetIgnoreList() []string {
	if x != nil {
		return x.IgnoreList
	}
	return nil
}

type isSlack_Credential interface {
	isSlack_Credential()
}

type Slack_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}

type Slack_Tokens struct {
	Tokens *credentialspb.SlackTokens `protobuf:"bytes,5,opt,name=tokens,proto3,oneof"`
}

func (*Slack_Token) isSlack_Credential() {}

func (*Slack_Tokens) isSlack_Credential() {}

type Test struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Test) Reset() {
	*x = Test{}
	mi := &file_sources_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Test) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Test) ProtoMessage() {}

func (x *Test) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Test.ProtoReflect.Descriptor instead.
func (*Test) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{23}
}

type Buildkite struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Buildkite_Token
	Credential    isBuildkite_Credential `protobuf_oneof:"credential"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Buildkite) Reset() {
	*x = Buildkite{}
	mi := &file_sources_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Buildkite) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Buildkite) ProtoMessage() {}

func (x *Buildkite) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Buildkite.ProtoReflect.Descriptor instead.
func (*Buildkite) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{24}
}

func (x *Buildkite) GetCredential() isBuildkite_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Buildkite) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*Buildkite_Token); ok {
			return x.Token
		}
	}
	return ""
}

type isBuildkite_Credential interface {
	isBuildkite_Credential()
}

type Buildkite_Token struct {
	Token string `protobuf:"bytes,1,opt,name=token,proto3,oneof"`
}

func (*Buildkite_Token) isBuildkite_Credential() {}

type Gerrit struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Gerrit_BasicAuth
	//	*Gerrit_Unauthenticated
	Credential    isGerrit_Credential `protobuf_oneof:"credential"`
	Projects      []string            `protobuf:"bytes,4,rep,name=projects,proto3" json:"projects,omitempty"`
	SkipBinaries  bool                `protobuf:"varint,5,opt,name=skip_binaries,json=skipBinaries,proto3" json:"skip_binaries,omitempty"`
	SkipArchives  bool                `protobuf:"varint,6,opt,name=skip_archives,json=skipArchives,proto3" json:"skip_archives,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Gerrit) Reset() {
	*x = Gerrit{}
	mi := &file_sources_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Gerrit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Gerrit) ProtoMessage() {}

func (x *Gerrit) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Gerrit.ProtoReflect.Descriptor instead.
func (*Gerrit) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{25}
}

func (x *Gerrit) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *Gerrit) GetCredential() isGerrit_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Gerrit) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*Gerrit_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *Gerrit) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*Gerrit_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *Gerrit) GetProjects() []string {
	if x != nil {
		return x.Projects
	}
	return nil
}

func (x *Gerrit) GetSkipBinaries() bool {
	if x != nil {
		return x.SkipBinaries
	}
	return false
}

func (x *Gerrit) GetSkipArchives() bool {
	if x != nil {
		return x.SkipArchives
	}
	return false
}

type isGerrit_Credential interface {
	isGerrit_Credential()
}

type Gerrit_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,2,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

type Gerrit_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,3,opt,name=unauthenticated,proto3,oneof"`
}

func (*Gerrit_BasicAuth) isGerrit_Credential() {}

func (*Gerrit_Unauthenticated) isGerrit_Credential() {}

type Jenkins struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Jenkins_BasicAuth
	//	*Jenkins_Header
	//	*Jenkins_Unauthenticated
	Credential            isJenkins_Credential `protobuf_oneof:"credential"`
	InsecureSkipVerifyTls bool                 `protobuf:"varint,4,opt,name=insecure_skip_verify_tls,json=insecureSkipVerifyTls,proto3" json:"insecure_skip_verify_tls,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *Jenkins) Reset() {
	*x = Jenkins{}
	mi := &file_sources_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Jenkins) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Jenkins) ProtoMessage() {}

func (x *Jenkins) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Jenkins.ProtoReflect.Descriptor instead.
func (*Jenkins) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{26}
}

func (x *Jenkins) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *Jenkins) GetCredential() isJenkins_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Jenkins) GetBasicAuth() *credentialspb.BasicAuth {
	if x != nil {
		if x, ok := x.Credential.(*Jenkins_BasicAuth); ok {
			return x.BasicAuth
		}
	}
	return nil
}

func (x *Jenkins) GetHeader() *credentialspb.Header {
	if x != nil {
		if x, ok := x.Credential.(*Jenkins_Header); ok {
			return x.Header
		}
	}
	return nil
}

func (x *Jenkins) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*Jenkins_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *Jenkins) GetInsecureSkipVerifyTls() bool {
	if x != nil {
		return x.InsecureSkipVerifyTls
	}
	return false
}

type isJenkins_Credential interface {
	isJenkins_Credential()
}

type Jenkins_BasicAuth struct {
	BasicAuth *credentialspb.BasicAuth `protobuf:"bytes,2,opt,name=basic_auth,json=basicAuth,proto3,oneof"`
}

type Jenkins_Header struct {
	Header *credentialspb.Header `protobuf:"bytes,3,opt,name=header,proto3,oneof"`
}

type Jenkins_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,5,opt,name=unauthenticated,proto3,oneof"`
}

func (*Jenkins_BasicAuth) isJenkins_Credential() {}

func (*Jenkins_Header) isJenkins_Credential() {}

func (*Jenkins_Unauthenticated) isJenkins_Credential() {}

type Teams struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Teams_Token
	//	*Teams_Authenticated
	//	*Teams_Oauth
	Credential    isTeams_Credential `protobuf_oneof:"credential"`
	Channels      []string           `protobuf:"bytes,4,rep,name=channels,proto3" json:"channels,omitempty"`
	IgnoreList    []string           `protobuf:"bytes,5,rep,name=ignore_list,json=ignoreList,proto3" json:"ignore_list,omitempty"`
	TeamIds       []string           `protobuf:"bytes,6,rep,name=team_ids,json=teamIds,proto3" json:"team_ids,omitempty"`
	TenantId      string             `protobuf:"bytes,8,opt,name=tenant_id,json=tenantId,proto3" json:"tenant_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Teams) Reset() {
	*x = Teams{}
	mi := &file_sources_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Teams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Teams) ProtoMessage() {}

func (x *Teams) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Teams.ProtoReflect.Descriptor instead.
func (*Teams) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{27}
}

func (x *Teams) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *Teams) GetCredential() isTeams_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Teams) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*Teams_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *Teams) GetAuthenticated() *credentialspb.ClientCredentials {
	if x != nil {
		if x, ok := x.Credential.(*Teams_Authenticated); ok {
			return x.Authenticated
		}
	}
	return nil
}

func (x *Teams) GetOauth() *credentialspb.Oauth2 {
	if x != nil {
		if x, ok := x.Credential.(*Teams_Oauth); ok {
			return x.Oauth
		}
	}
	return nil
}

func (x *Teams) GetChannels() []string {
	if x != nil {
		return x.Channels
	}
	return nil
}

func (x *Teams) GetIgnoreList() []string {
	if x != nil {
		return x.IgnoreList
	}
	return nil
}

func (x *Teams) GetTeamIds() []string {
	if x != nil {
		return x.TeamIds
	}
	return nil
}

func (x *Teams) GetTenantId() string {
	if x != nil {
		return x.TenantId
	}
	return ""
}

type isTeams_Credential interface {
	isTeams_Credential()
}

type Teams_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}

type Teams_Authenticated struct {
	Authenticated *credentialspb.ClientCredentials `protobuf:"bytes,3,opt,name=authenticated,proto3,oneof"`
}

type Teams_Oauth struct {
	Oauth *credentialspb.Oauth2 `protobuf:"bytes,7,opt,name=oauth,proto3,oneof"`
}

func (*Teams_Token) isTeams_Credential() {}

func (*Teams_Authenticated) isTeams_Credential() {}

func (*Teams_Oauth) isTeams_Credential() {}

type Syslog struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Protocol      string                 `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	ListenAddress string                 `protobuf:"bytes,2,opt,name=listen_address,json=listenAddress,proto3" json:"listen_address,omitempty"`
	TlsCert       string                 `protobuf:"bytes,3,opt,name=tlsCert,proto3" json:"tlsCert,omitempty"`
	TlsKey        string                 `protobuf:"bytes,4,opt,name=tlsKey,proto3" json:"tlsKey,omitempty"`
	Format        string                 `protobuf:"bytes,5,opt,name=format,proto3" json:"format,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Syslog) Reset() {
	*x = Syslog{}
	mi := &file_sources_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Syslog) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Syslog) ProtoMessage() {}

func (x *Syslog) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Syslog.ProtoReflect.Descriptor instead.
func (*Syslog) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{28}
}

func (x *Syslog) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *Syslog) GetListenAddress() string {
	if x != nil {
		return x.ListenAddress
	}
	return ""
}

func (x *Syslog) GetTlsCert() string {
	if x != nil {
		return x.TlsCert
	}
	return ""
}

func (x *Syslog) GetTlsKey() string {
	if x != nil {
		return x.TlsKey
	}
	return ""
}

func (x *Syslog) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

type Forager struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Forager_Unauthenticated
	Credential    isForager_Credential   `protobuf_oneof:"credential"`
	Domains       []string               `protobuf:"bytes,2,rep,name=domains,proto3" json:"domains,omitempty"`
	MaxDepth      int64                  `protobuf:"varint,3,opt,name=max_depth,json=maxDepth,proto3" json:"max_depth,omitempty"`
	Since         *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=since,proto3" json:"since,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Forager) Reset() {
	*x = Forager{}
	mi := &file_sources_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Forager) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Forager) ProtoMessage() {}

func (x *Forager) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Forager.ProtoReflect.Descriptor instead.
func (*Forager) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{29}
}

func (x *Forager) GetCredential() isForager_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Forager) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*Forager_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *Forager) GetDomains() []string {
	if x != nil {
		return x.Domains
	}
	return nil
}

func (x *Forager) GetMaxDepth() int64 {
	if x != nil {
		return x.MaxDepth
	}
	return 0
}

func (x *Forager) GetSince() *timestamppb.Timestamp {
	if x != nil {
		return x.Since
	}
	return nil
}

type isForager_Credential interface {
	isForager_Credential()
}

type Forager_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,1,opt,name=unauthenticated,proto3,oneof"`
}

func (*Forager_Unauthenticated) isForager_Credential() {}

type SlackRealtime struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*SlackRealtime_Tokens
	Credential    isSlackRealtime_Credential `protobuf_oneof:"credential"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SlackRealtime) Reset() {
	*x = SlackRealtime{}
	mi := &file_sources_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SlackRealtime) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SlackRealtime) ProtoMessage() {}

func (x *SlackRealtime) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SlackRealtime.ProtoReflect.Descriptor instead.
func (*SlackRealtime) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{30}
}

func (x *SlackRealtime) GetCredential() isSlackRealtime_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *SlackRealtime) GetTokens() *credentialspb.SlackTokens {
	if x != nil {
		if x, ok := x.Credential.(*SlackRealtime_Tokens); ok {
			return x.Tokens
		}
	}
	return nil
}

type isSlackRealtime_Credential interface {
	isSlackRealtime_Credential()
}

type SlackRealtime_Tokens struct {
	Tokens *credentialspb.SlackTokens `protobuf:"bytes,1,opt,name=tokens,proto3,oneof"`
}

func (*SlackRealtime_Tokens) isSlackRealtime_Credential() {}

type Sharepoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Sharepoint_Oauth
	Credential    isSharepoint_Credential `protobuf_oneof:"credential"`
	SiteUrl       string                  `protobuf:"bytes,2,opt,name=site_url,json=siteUrl,proto3" json:"site_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Sharepoint) Reset() {
	*x = Sharepoint{}
	mi := &file_sources_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Sharepoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Sharepoint) ProtoMessage() {}

func (x *Sharepoint) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Sharepoint.ProtoReflect.Descriptor instead.
func (*Sharepoint) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{31}
}

func (x *Sharepoint) GetCredential() isSharepoint_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Sharepoint) GetOauth() *credentialspb.Oauth2 {
	if x != nil {
		if x, ok := x.Credential.(*Sharepoint_Oauth); ok {
			return x.Oauth
		}
	}
	return nil
}

func (x *Sharepoint) GetSiteUrl() string {
	if x != nil {
		return x.SiteUrl
	}
	return ""
}

type isSharepoint_Credential interface {
	isSharepoint_Credential()
}

type Sharepoint_Oauth struct {
	Oauth *credentialspb.Oauth2 `protobuf:"bytes,1,opt,name=oauth,proto3,oneof"`
}

func (*Sharepoint_Oauth) isSharepoint_Credential() {}

type AzureRepos struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*AzureRepos_Token
	//	*AzureRepos_Oauth
	Credential      isAzureRepos_Credential `protobuf_oneof:"credential"`
	Repositories    []string                `protobuf:"bytes,4,rep,name=repositories,proto3" json:"repositories,omitempty"`
	Organizations   []string                `protobuf:"bytes,5,rep,name=organizations,proto3" json:"organizations,omitempty"`
	Projects        []string                `protobuf:"bytes,6,rep,name=projects,proto3" json:"projects,omitempty"`
	IncludeForks    bool                    `protobuf:"varint,7,opt,name=include_forks,json=includeForks,proto3" json:"include_forks,omitempty"`
	IgnoreRepos     []string                `protobuf:"bytes,8,rep,name=ignore_repos,json=ignoreRepos,proto3" json:"ignore_repos,omitempty"`
	IncludeRepos    []string                `protobuf:"bytes,9,rep,name=include_repos,json=includeRepos,proto3" json:"include_repos,omitempty"`
	IncludeProjects []string                `protobuf:"bytes,10,rep,name=include_projects,json=includeProjects,proto3" json:"include_projects,omitempty"`
	IgnoreProjects  []string                `protobuf:"bytes,11,rep,name=ignore_projects,json=ignoreProjects,proto3" json:"ignore_projects,omitempty"`
	SkipBinaries    bool                    `protobuf:"varint,12,opt,name=skip_binaries,json=skipBinaries,proto3" json:"skip_binaries,omitempty"`
	SkipArchives    bool                    `protobuf:"varint,13,opt,name=skip_archives,json=skipArchives,proto3" json:"skip_archives,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AzureRepos) Reset() {
	*x = AzureRepos{}
	mi := &file_sources_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AzureRepos) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AzureRepos) ProtoMessage() {}

func (x *AzureRepos) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AzureRepos.ProtoReflect.Descriptor instead.
func (*AzureRepos) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{32}
}

func (x *AzureRepos) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *AzureRepos) GetCredential() isAzureRepos_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *AzureRepos) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*AzureRepos_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *AzureRepos) GetOauth() *credentialspb.Oauth2 {
	if x != nil {
		if x, ok := x.Credential.(*AzureRepos_Oauth); ok {
			return x.Oauth
		}
	}
	return nil
}

func (x *AzureRepos) GetRepositories() []string {
	if x != nil {
		return x.Repositories
	}
	return nil
}

func (x *AzureRepos) GetOrganizations() []string {
	if x != nil {
		return x.Organizations
	}
	return nil
}

func (x *AzureRepos) GetProjects() []string {
	if x != nil {
		return x.Projects
	}
	return nil
}

func (x *AzureRepos) GetIncludeForks() bool {
	if x != nil {
		return x.IncludeForks
	}
	return false
}

func (x *AzureRepos) GetIgnoreRepos() []string {
	if x != nil {
		return x.IgnoreRepos
	}
	return nil
}

func (x *AzureRepos) GetIncludeRepos() []string {
	if x != nil {
		return x.IncludeRepos
	}
	return nil
}

func (x *AzureRepos) GetIncludeProjects() []string {
	if x != nil {
		return x.IncludeProjects
	}
	return nil
}

func (x *AzureRepos) GetIgnoreProjects() []string {
	if x != nil {
		return x.IgnoreProjects
	}
	return nil
}

func (x *AzureRepos) GetSkipBinaries() bool {
	if x != nil {
		return x.SkipBinaries
	}
	return false
}

func (x *AzureRepos) GetSkipArchives() bool {
	if x != nil {
		return x.SkipArchives
	}
	return false
}

type isAzureRepos_Credential interface {
	isAzureRepos_Credential()
}

type AzureRepos_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}

type AzureRepos_Oauth struct {
	Oauth *credentialspb.Oauth2 `protobuf:"bytes,3,opt,name=oauth,proto3,oneof"`
}

func (*AzureRepos_Token) isAzureRepos_Credential() {}

func (*AzureRepos_Oauth) isAzureRepos_Credential() {}

type Postman struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Postman_Unauthenticated
	//	*Postman_Token
	Credential          isPostman_Credential `protobuf_oneof:"credential"`
	Workspaces          []string             `protobuf:"bytes,3,rep,name=workspaces,proto3" json:"workspaces,omitempty"`
	Collections         []string             `protobuf:"bytes,4,rep,name=collections,proto3" json:"collections,omitempty"`
	Environments        []string             `protobuf:"bytes,5,rep,name=environments,proto3" json:"environments,omitempty"`
	ExcludeCollections  []string             `protobuf:"bytes,6,rep,name=exclude_collections,json=excludeCollections,proto3" json:"exclude_collections,omitempty"`
	ExcludeEnvironments []string             `protobuf:"bytes,7,rep,name=exclude_environments,json=excludeEnvironments,proto3" json:"exclude_environments,omitempty"`
	IncludeCollections  []string             `protobuf:"bytes,8,rep,name=include_collections,json=includeCollections,proto3" json:"include_collections,omitempty"`
	IncludeEnvironments []string             `protobuf:"bytes,9,rep,name=include_environments,json=includeEnvironments,proto3" json:"include_environments,omitempty"`
	DetectorKeywords    []string             `protobuf:"bytes,10,rep,name=detector_keywords,json=detectorKeywords,proto3" json:"detector_keywords,omitempty"`
	WorkspacePaths      []string             `protobuf:"bytes,11,rep,name=workspace_paths,json=workspacePaths,proto3" json:"workspace_paths,omitempty"`
	CollectionPaths     []string             `protobuf:"bytes,12,rep,name=collection_paths,json=collectionPaths,proto3" json:"collection_paths,omitempty"`
	EnvironmentPaths    []string             `protobuf:"bytes,13,rep,name=environment_paths,json=environmentPaths,proto3" json:"environment_paths,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *Postman) Reset() {
	*x = Postman{}
	mi := &file_sources_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Postman) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Postman) ProtoMessage() {}

func (x *Postman) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Postman.ProtoReflect.Descriptor instead.
func (*Postman) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{33}
}

func (x *Postman) GetCredential() isPostman_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Postman) GetUnauthenticated() *credentialspb.Unauthenticated {
	if x != nil {
		if x, ok := x.Credential.(*Postman_Unauthenticated); ok {
			return x.Unauthenticated
		}
	}
	return nil
}

func (x *Postman) GetToken() string {
	if x != nil {
		if x, ok := x.Credential.(*Postman_Token); ok {
			return x.Token
		}
	}
	return ""
}

func (x *Postman) GetWorkspaces() []string {
	if x != nil {
		return x.Workspaces
	}
	return nil
}

func (x *Postman) GetCollections() []string {
	if x != nil {
		return x.Collections
	}
	return nil
}

func (x *Postman) GetEnvironments() []string {
	if x != nil {
		return x.Environments
	}
	return nil
}

func (x *Postman) GetExcludeCollections() []string {
	if x != nil {
		return x.ExcludeCollections
	}
	return nil
}

func (x *Postman) GetExcludeEnvironments() []string {
	if x != nil {
		return x.ExcludeEnvironments
	}
	return nil
}

func (x *Postman) GetIncludeCollections() []string {
	if x != nil {
		return x.IncludeCollections
	}
	return nil
}

func (x *Postman) GetIncludeEnvironments() []string {
	if x != nil {
		return x.IncludeEnvironments
	}
	return nil
}

func (x *Postman) GetDetectorKeywords() []string {
	if x != nil {
		return x.DetectorKeywords
	}
	return nil
}

func (x *Postman) GetWorkspacePaths() []string {
	if x != nil {
		return x.WorkspacePaths
	}
	return nil
}

func (x *Postman) GetCollectionPaths() []string {
	if x != nil {
		return x.CollectionPaths
	}
	return nil
}

func (x *Postman) GetEnvironmentPaths() []string {
	if x != nil {
		return x.EnvironmentPaths
	}
	return nil
}

type isPostman_Credential interface {
	isPostman_Credential()
}

type Postman_Unauthenticated struct {
	Unauthenticated *credentialspb.Unauthenticated `protobuf:"bytes,1,opt,name=unauthenticated,proto3,oneof"`
}

type Postman_Token struct {
	Token string `protobuf:"bytes,2,opt,name=token,proto3,oneof"`
}

func (*Postman_Unauthenticated) isPostman_Credential() {}

func (*Postman_Token) isPostman_Credential() {}

type Webhook struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ListenAddress string                 `protobuf:"bytes,1,opt,name=listen_address,json=listenAddress,proto3" json:"listen_address,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Webhook_Header
	Credential    isWebhook_Credential `protobuf_oneof:"credential"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Webhook) Reset() {
	*x = Webhook{}
	mi := &file_sources_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Webhook) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Webhook) ProtoMessage() {}

func (x *Webhook) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Webhook.ProtoReflect.Descriptor instead.
func (*Webhook) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{34}
}

func (x *Webhook) GetListenAddress() string {
	if x != nil {
		return x.ListenAddress
	}
	return ""
}

func (x *Webhook) GetCredential() isWebhook_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Webhook) GetHeader() *credentialspb.Header {
	if x != nil {
		if x, ok := x.Credential.(*Webhook_Header); ok {
			return x.Header
		}
	}
	return nil
}

type isWebhook_Credential interface {
	isWebhook_Credential()
}

type Webhook_Header struct {
	Header *credentialspb.Header `protobuf:"bytes,2,opt,name=header,proto3,oneof"`
}

func (*Webhook_Header) isWebhook_Credential() {}

type SlackContinuous struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ProjectId     string                 `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	Topic         string                 `protobuf:"bytes,2,opt,name=topic,proto3" json:"topic,omitempty"`
	Subscription  string                 `protobuf:"bytes,3,opt,name=subscription,proto3" json:"subscription,omitempty"`
	PrivateKey    []byte                 `protobuf:"bytes,4,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SlackContinuous) Reset() {
	*x = SlackContinuous{}
	mi := &file_sources_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SlackContinuous) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SlackContinuous) ProtoMessage() {}

func (x *SlackContinuous) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SlackContinuous.ProtoReflect.Descriptor instead.
func (*SlackContinuous) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{35}
}

func (x *SlackContinuous) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *SlackContinuous) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *SlackContinuous) GetSubscription() string {
	if x != nil {
		return x.Subscription
	}
	return ""
}

func (x *SlackContinuous) GetPrivateKey() []byte {
	if x != nil {
		return x.PrivateKey
	}
	return nil
}

type Elasticsearch struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Nodes          []string               `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	Username       string                 `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password       string                 `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	CloudId        string                 `protobuf:"bytes,4,opt,name=cloud_id,json=cloudId,proto3" json:"cloud_id,omitempty"`
	ApiKey         string                 `protobuf:"bytes,5,opt,name=api_key,json=apiKey,proto3" json:"api_key,omitempty"`
	ServiceToken   string                 `protobuf:"bytes,6,opt,name=service_token,json=serviceToken,proto3" json:"service_token,omitempty"`
	IndexPattern   string                 `protobuf:"bytes,7,opt,name=index_pattern,json=indexPattern,proto3" json:"index_pattern,omitempty"`
	QueryJson      string                 `protobuf:"bytes,8,opt,name=query_json,json=queryJson,proto3" json:"query_json,omitempty"`
	SinceTimestamp string                 `protobuf:"bytes,9,opt,name=since_timestamp,json=sinceTimestamp,proto3" json:"since_timestamp,omitempty"`
	BestEffortScan bool                   `protobuf:"varint,10,opt,name=best_effort_scan,json=bestEffortScan,proto3" json:"best_effort_scan,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Elasticsearch) Reset() {
	*x = Elasticsearch{}
	mi := &file_sources_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Elasticsearch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Elasticsearch) ProtoMessage() {}

func (x *Elasticsearch) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Elasticsearch.ProtoReflect.Descriptor instead.
func (*Elasticsearch) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{36}
}

func (x *Elasticsearch) GetNodes() []string {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *Elasticsearch) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *Elasticsearch) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *Elasticsearch) GetCloudId() string {
	if x != nil {
		return x.CloudId
	}
	return ""
}

func (x *Elasticsearch) GetApiKey() string {
	if x != nil {
		return x.ApiKey
	}
	return ""
}

func (x *Elasticsearch) GetServiceToken() string {
	if x != nil {
		return x.ServiceToken
	}
	return ""
}

func (x *Elasticsearch) GetIndexPattern() string {
	if x != nil {
		return x.IndexPattern
	}
	return ""
}

func (x *Elasticsearch) GetQueryJson() string {
	if x != nil {
		return x.QueryJson
	}
	return ""
}

func (x *Elasticsearch) GetSinceTimestamp() string {
	if x != nil {
		return x.SinceTimestamp
	}
	return ""
}

func (x *Elasticsearch) GetBestEffortScan() bool {
	if x != nil {
		return x.BestEffortScan
	}
	return false
}

type Sentry struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Endpoint string                 `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Types that are valid to be assigned to Credential:
	//
	//	*Sentry_AuthToken
	//	*Sentry_DsnKey
	//	*Sentry_ApiKey
	Credential            isSentry_Credential `protobuf_oneof:"credential"`
	InsecureSkipVerifyTls bool                `protobuf:"varint,5,opt,name=insecure_skip_verify_tls,json=insecureSkipVerifyTls,proto3" json:"insecure_skip_verify_tls,omitempty"`
	Projects              string              `protobuf:"bytes,6,opt,name=projects,proto3" json:"projects,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *Sentry) Reset() {
	*x = Sentry{}
	mi := &file_sources_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Sentry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Sentry) ProtoMessage() {}

func (x *Sentry) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Sentry.ProtoReflect.Descriptor instead.
func (*Sentry) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{37}
}

func (x *Sentry) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *Sentry) GetCredential() isSentry_Credential {
	if x != nil {
		return x.Credential
	}
	return nil
}

func (x *Sentry) GetAuthToken() string {
	if x != nil {
		if x, ok := x.Credential.(*Sentry_AuthToken); ok {
			return x.AuthToken
		}
	}
	return ""
}

func (x *Sentry) GetDsnKey() string {
	if x != nil {
		if x, ok := x.Credential.(*Sentry_DsnKey); ok {
			return x.DsnKey
		}
	}
	return ""
}

func (x *Sentry) GetApiKey() string {
	if x != nil {
		if x, ok := x.Credential.(*Sentry_ApiKey); ok {
			return x.ApiKey
		}
	}
	return ""
}

func (x *Sentry) GetInsecureSkipVerifyTls() bool {
	if x != nil {
		return x.InsecureSkipVerifyTls
	}
	return false
}

func (x *Sentry) GetProjects() string {
	if x != nil {
		return x.Projects
	}
	return ""
}

type isSentry_Credential interface {
	isSentry_Credential()
}

type Sentry_AuthToken struct {
	AuthToken string `protobuf:"bytes,2,opt,name=auth_token,json=authToken,proto3,oneof"`
}

type Sentry_DsnKey struct {
	DsnKey string `protobuf:"bytes,3,opt,name=dsn_key,json=dsnKey,proto3,oneof"`
}

type Sentry_ApiKey struct {
	ApiKey string `protobuf:"bytes,4,opt,name=api_key,json=apiKey,proto3,oneof"`
}

func (*Sentry_AuthToken) isSentry_Credential() {}

func (*Sentry_DsnKey) isSentry_Credential() {}

func (*Sentry_ApiKey) isSentry_Credential() {}

type Stdin struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Stdin) Reset() {
	*x = Stdin{}
	mi := &file_sources_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Stdin) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Stdin) ProtoMessage() {}

func (x *Stdin) ProtoReflect() protoreflect.Message {
	mi := &file_sources_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Stdin.ProtoReflect.Descriptor instead.
func (*Stdin) Descriptor() ([]byte, []int) {
	return file_sources_proto_rawDescGZIP(), []int{38}
}

var File_sources_proto protoreflect.FileDescriptor

const file_sources_proto_rawDesc = "" +
	"\n" +
	"\rsources.proto\x12\asources\x1a\x17validate/validate.proto\x1a\x11credentials.proto\x1a\x19google/protobuf/any.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xe8\x01\n" +
	"\vLocalSource\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12B\n" +
	"\rscan_interval\x18\x03 \x01(\v2\x19.google.protobuf.DurationB\x02\x18\x01R\fscanInterval\x12\x16\n" +
	"\x06verify\x18\x04 \x01(\bR\x06verify\x124\n" +
	"\n" +
	"connection\x18\x05 \x01(\v2\x14.google.protobuf.AnyR\n" +
	"connection\x12\x1f\n" +
	"\vscan_period\x18\x06 \x01(\tR\n" +
	"scanPeriod\"\xd5\x02\n" +
	"\vArtifactory\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x127\n" +
	"\n" +
	"basic_auth\x18\x02 \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuth\x12#\n" +
	"\faccess_token\x18\x03 \x01(\tH\x00R\vaccessToken\x12H\n" +
	"\x0funauthenticated\x18\a \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x12\"\n" +
	"\frepositories\x18\x04 \x03(\tR\frepositories\x12#\n" +
	"\rinclude_paths\x18\x05 \x03(\tR\fincludePaths\x12!\n" +
	"\fignore_paths\x18\x06 \x03(\tR\vignorePathsB\f\n" +
	"\n" +
	"credential\"\xae\x02\n" +
	"\fAzureStorage\x12-\n" +
	"\x11connection_string\x18\x01 \x01(\tH\x00R\x10connectionString\x127\n" +
	"\n" +
	"basic_auth\x18\x02 \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuth\x12/\n" +
	"\x12client_certificate\x18\x03 \x01(\tH\x00R\x11clientCertificate\x12H\n" +
	"\x0funauthenticated\x18\x04 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x12-\n" +
	"\x12storage_containers\x18\x05 \x03(\tR\x11storageContainersB\f\n" +
	"\n" +
	"credential\"\x9f\x03\n" +
	"\tBitbucket\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x12\x16\n" +
	"\x05token\x18\x02 \x01(\tH\x00R\x05token\x12+\n" +
	"\x05oauth\x18\x03 \x01(\v2\x13.credentials.Oauth2H\x00R\x05oauth\x127\n" +
	"\n" +
	"basic_auth\x18\x04 \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuth\x12\"\n" +
	"\frepositories\x18\x05 \x03(\tR\frepositories\x12!\n" +
	"\fignore_repos\x18\x06 \x03(\tR\vignoreRepos\x12#\n" +
	"\rskip_binaries\x18\a \x01(\bR\fskipBinaries\x12#\n" +
	"\rskip_archives\x18\b \x01(\bR\fskipArchives\x12O\n" +
	"\x11installation_type\x18\t \x01(\x0e2\".sources.BitbucketInstallationTypeR\x10installationTypeB\f\n" +
	"\n" +
	"credential\"V\n" +
	"\bCircleCI\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x12\x16\n" +
	"\x05token\x18\x02 \x01(\tH\x00R\x05tokenB\f\n" +
	"\n" +
	"credential\"V\n" +
	"\bTravisCI\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x12\x16\n" +
	"\x05token\x18\x02 \x01(\tH\x00R\x05tokenB\f\n" +
	"\n" +
	"credential\"\xa7\x04\n" +
	"\n" +
	"Confluence\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x12H\n" +
	"\x0funauthenticated\x18\x02 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x127\n" +
	"\n" +
	"basic_auth\x18\x03 \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuth\x12\x16\n" +
	"\x05token\x18\x04 \x01(\tH\x00R\x05token\x12H\n" +
	"\fspaces_scope\x18\x05 \x01(\x0e2%.sources.Confluence.GetAllSpacesScopeR\vspacesScope\x127\n" +
	"\x18insecure_skip_verify_tls\x18\x06 \x01(\bR\x15insecureSkipVerifyTls\x12\x16\n" +
	"\x06spaces\x18\a \x03(\tR\x06spaces\x12#\n" +
	"\rignore_spaces\x18\b \x03(\tR\fignoreSpaces\x12/\n" +
	"\x13include_attachments\x18\t \x01(\bR\x12includeAttachments\x12!\n" +
	"\fskip_history\x18\n" +
	" \x01(\bR\vskipHistory\"6\n" +
	"\x11GetAllSpacesScope\x12\a\n" +
	"\x03ALL\x10\x00\x12\n" +
	"\n" +
	"\x06GLOBAL\x10\x01\x12\f\n" +
	"\bPERSONAL\x10\x02B\f\n" +
	"\n" +
	"credential\"\xa6\x02\n" +
	"\x06Docker\x12H\n" +
	"\x0funauthenticated\x18\x01 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x127\n" +
	"\n" +
	"basic_auth\x18\x02 \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuth\x12#\n" +
	"\fbearer_token\x18\x03 \x01(\tH\x00R\vbearerToken\x12)\n" +
	"\x0fdocker_keychain\x18\x04 \x01(\bH\x00R\x0edockerKeychain\x12\x16\n" +
	"\x06images\x18\x05 \x03(\tR\x06images\x12#\n" +
	"\rexclude_paths\x18\x06 \x03(\tR\fexcludePathsB\f\n" +
	"\n" +
	"credential\"l\n" +
	"\x03ECR\x127\n" +
	"\n" +
	"access_key\x18\x01 \x01(\v2\x16.credentials.KeySecretH\x00R\taccessKey\x12\x1e\n" +
	"\n" +
	"registries\x18\x02 \x03(\tR\n" +
	"registriesB\f\n" +
	"\n" +
	"credential\"\xa0\x01\n" +
	"\n" +
	"Filesystem\x12 \n" +
	"\vdirectories\x18\x01 \x03(\tR\vdirectories\x12\x14\n" +
	"\x05paths\x18\x02 \x03(\tR\x05paths\x12,\n" +
	"\x12include_paths_file\x18\x03 \x01(\tR\x10includePathsFile\x12,\n" +
	"\x12exclude_paths_file\x18\x04 \x01(\tR\x10excludePathsFile\"\xab\x04\n" +
	"\x03GCS\x122\n" +
	"\x14json_service_account\x18\x01 \x01(\tH\x00R\x12jsonServiceAccount\x12\x19\n" +
	"\aapi_key\x18\x02 \x01(\tH\x00R\x06apiKey\x12H\n" +
	"\x0funauthenticated\x18\x03 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x121\n" +
	"\x03adc\x18\x04 \x01(\v2\x1d.credentials.CloudEnvironmentH\x00R\x03adc\x122\n" +
	"\x14service_account_file\x18\v \x01(\tH\x00R\x12serviceAccountFile\x12+\n" +
	"\x05oauth\x18\f \x01(\v2\x13.credentials.Oauth2H\x00R\x05oauth\x12\x1d\n" +
	"\n" +
	"project_id\x18\x05 \x01(\tR\tprojectId\x12'\n" +
	"\x0finclude_buckets\x18\x06 \x03(\tR\x0eincludeBuckets\x12'\n" +
	"\x0fexclude_buckets\x18\a \x03(\tR\x0eexcludeBuckets\x12'\n" +
	"\x0finclude_objects\x18\b \x03(\tR\x0eincludeObjects\x12'\n" +
	"\x0fexclude_objects\x18\t \x03(\tR\x0eexcludeObjects\x12&\n" +
	"\x0fmax_object_size\x18\n" +
	" \x01(\x03R\rmaxObjectSizeB\f\n" +
	"\n" +
	"credential\"\xc5\x04\n" +
	"\x03Git\x127\n" +
	"\n" +
	"basic_auth\x18\x01 \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuth\x12H\n" +
	"\x0funauthenticated\x18\x02 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x121\n" +
	"\bssh_auth\x18\x05 \x01(\v2\x14.credentials.SSHAuthH\x00R\asshAuth\x12 \n" +
	"\vdirectories\x18\x03 \x03(\tR\vdirectories\x12\"\n" +
	"\frepositories\x18\x04 \x03(\tR\frepositories\x12\x12\n" +
	"\x04head\x18\x06 \x01(\tR\x04head\x12\x12\n" +
	"\x04base\x18\a \x01(\tR\x04base\x12\x12\n" +
	"\x04bare\x18\b \x01(\bR\x04bare\x12,\n" +
	"\x12include_paths_file\x18\t \x01(\tR\x10includePathsFile\x12,\n" +
	"\x12exclude_paths_file\x18\n" +
	" \x01(\tR\x10excludePathsFile\x12#\n" +
	"\rexclude_globs\x18\v \x01(\tR\fexcludeGlobs\x12\x1b\n" +
	"\tmax_depth\x18\f \x01(\x03R\bmaxDepth\x12\x10\n" +
	"\x03uri\x18\r \x01(\tR\x03uri\x12#\n" +
	"\rskip_binaries\x18\x0e \x01(\bR\fskipBinaries\x12#\n" +
	"\rskip_archives\x18\x0f \x01(\bR\fskipArchivesB\f\n" +
	"\n" +
	"credential\"\xeb\x03\n" +
	"\x06GitLab\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x12\x16\n" +
	"\x05token\x18\x02 \x01(\tH\x00R\x05token\x12+\n" +
	"\x05oauth\x18\x03 \x01(\v2\x13.credentials.Oauth2H\x00R\x05oauth\x127\n" +
	"\n" +
	"basic_auth\x18\x04 \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuth\x12\"\n" +
	"\frepositories\x18\x05 \x03(\tR\frepositories\x12!\n" +
	"\fignore_repos\x18\x06 \x03(\tR\vignoreRepos\x12#\n" +
	"\rskip_binaries\x18\a \x01(\bR\fskipBinaries\x12#\n" +
	"\rskip_archives\x18\b \x01(\bR\fskipArchives\x12#\n" +
	"\rinclude_repos\x18\t \x03(\tR\fincludeRepos\x12L\n" +
	"#exclude_projects_shared_into_groups\x18\n" +
	" \x01(\bR\x1fexcludeProjectsSharedIntoGroups\x12+\n" +
	"\x12remove_auth_in_url\x18\v \x01(\bR\x0fremoveAuthInUrlB\f\n" +
	"\n" +
	"credential\"\x8d\a\n" +
	"\x06GitHub\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x127\n" +
	"\n" +
	"github_app\x18\x02 \x01(\v2\x16.credentials.GitHubAppH\x00R\tgithubApp\x12\x16\n" +
	"\x05token\x18\x03 \x01(\tH\x00R\x05token\x12H\n" +
	"\x0funauthenticated\x18\x04 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x127\n" +
	"\n" +
	"basic_auth\x18\r \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuth\x12\"\n" +
	"\frepositories\x18\x05 \x03(\tR\frepositories\x12$\n" +
	"\rorganizations\x18\x06 \x03(\tR\rorganizations\x12\x1c\n" +
	"\tscanUsers\x18\a \x01(\bR\tscanUsers\x12\"\n" +
	"\fincludeForks\x18\b \x01(\bR\fincludeForks\x12\x12\n" +
	"\x04head\x18\t \x01(\tR\x04head\x12\x12\n" +
	"\x04base\x18\n" +
	" \x01(\tR\x04base\x12!\n" +
	"\fignore_repos\x18\v \x03(\tR\vignoreRepos\x12#\n" +
	"\rinclude_repos\x18\f \x03(\tR\fincludeRepos\x12A\n" +
	"\x1dinclude_pull_request_comments\x18\x0e \x01(\bR\x1aincludePullRequestComments\x124\n" +
	"\x16include_issue_comments\x18\x0f \x01(\bR\x14includeIssueComments\x122\n" +
	"\x15include_gist_comments\x18\x10 \x01(\bR\x13includeGistComments\x12#\n" +
	"\rskip_binaries\x18\x11 \x01(\bR\fskipBinaries\x12#\n" +
	"\rskip_archives\x18\x12 \x01(\bR\fskipArchives\x12#\n" +
	"\rinclude_wikis\x18\x13 \x01(\bR\fincludeWikis\x126\n" +
	"\x17comments_timeframe_days\x18\x14 \x01(\rR\x15commentsTimeframeDays\x12+\n" +
	"\x12remove_auth_in_url\x18\x15 \x01(\bR\x0fremoveAuthInUrlB\f\n" +
	"\n" +
	"credential\"\xe4\x01\n" +
	"\x12GitHubExperimental\x12\x1e\n" +
	"\n" +
	"repository\x18\x01 \x01(\tR\n" +
	"repository\x12\x16\n" +
	"\x05token\x18\x02 \x01(\tH\x00R\x05token\x12)\n" +
	"\x10object_discovery\x18\x03 \x01(\bR\x0fobjectDiscovery\x12/\n" +
	"\x13collision_threshold\x18\x04 \x01(\x03R\x12collisionThreshold\x12,\n" +
	"\x12delete_cached_data\x18\x05 \x01(\bR\x10deleteCachedDataB\f\n" +
	"\n" +
	"credential\"\xe4\x02\n" +
	"\x0eGitHubRealtime\x12#\n" +
	"\rlistener_port\x18\x01 \x01(\rR\flistenerPort\x12%\n" +
	"\x0ewebhook_secret\x18\x02 \x01(\tR\rwebhookSecret\x12$\n" +
	"\bendpoint\x18\x03 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x127\n" +
	"\n" +
	"github_app\x18\x04 \x01(\v2\x16.credentials.GitHubAppH\x00R\tgithubApp\x12\x16\n" +
	"\x05token\x18\x05 \x01(\tH\x00R\x05token\x12H\n" +
	"\x0funauthenticated\x18\x06 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x127\n" +
	"\n" +
	"basic_auth\x18\a \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuthB\f\n" +
	"\n" +
	"credential\"B\n" +
	"\vGoogleDrive\x12%\n" +
	"\rrefresh_token\x18\x01 \x01(\tH\x00R\frefreshTokenB\f\n" +
	"\n" +
	"credential\"\xe5\x05\n" +
	"\vHuggingface\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x12\x16\n" +
	"\x05token\x18\x02 \x01(\tH\x00R\x05token\x12H\n" +
	"\x0funauthenticated\x18\x03 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x12\x16\n" +
	"\x06models\x18\x04 \x03(\tR\x06models\x12\x16\n" +
	"\x06spaces\x18\x05 \x03(\tR\x06spaces\x12\x1a\n" +
	"\bdatasets\x18\f \x03(\tR\bdatasets\x12$\n" +
	"\rorganizations\x18\x06 \x03(\tR\rorganizations\x12\x14\n" +
	"\x05users\x18\x0f \x03(\tR\x05users\x12#\n" +
	"\rignore_models\x18\a \x03(\tR\fignoreModels\x12%\n" +
	"\x0einclude_models\x18\b \x03(\tR\rincludeModels\x12#\n" +
	"\rignore_spaces\x18\t \x03(\tR\fignoreSpaces\x12%\n" +
	"\x0einclude_spaces\x18\n" +
	" \x03(\tR\rincludeSpaces\x12'\n" +
	"\x0fignore_datasets\x18\r \x03(\tR\x0eignoreDatasets\x12)\n" +
	"\x10include_datasets\x18\x0e \x03(\tR\x0fincludeDatasets\x12&\n" +
	"\x0fskip_all_models\x18\x10 \x01(\bR\rskipAllModels\x12&\n" +
	"\x0fskip_all_spaces\x18\x11 \x01(\bR\rskipAllSpaces\x12*\n" +
	"\x11skip_all_datasets\x18\x12 \x01(\bR\x0fskipAllDatasets\x12/\n" +
	"\x13include_discussions\x18\v \x01(\bR\x12includeDiscussions\x12\x1f\n" +
	"\vinclude_prs\x18\x13 \x01(\bR\n" +
	"includePrsB\f\n" +
	"\n" +
	"credential\"\x80\x03\n" +
	"\x04JIRA\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x127\n" +
	"\n" +
	"basic_auth\x18\x02 \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuth\x12H\n" +
	"\x0funauthenticated\x18\x03 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x12+\n" +
	"\x05oauth\x18\x04 \x01(\v2\x13.credentials.Oauth2H\x00R\x05oauth\x12\x16\n" +
	"\x05token\x18\x06 \x01(\tH\x00R\x05token\x12\x1a\n" +
	"\bprojects\x18\x05 \x03(\tR\bprojects\x12'\n" +
	"\x0fignore_projects\x18\a \x03(\tR\x0eignoreProjects\x127\n" +
	"\x18insecure_skip_verify_tls\x18\b \x01(\bR\x15insecureSkipVerifyTlsB\f\n" +
	"\n" +
	"credential\"s\n" +
	"\x19NPMUnauthenticatedPackage\x12H\n" +
	"\x0funauthenticated\x18\x01 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticatedB\f\n" +
	"\n" +
	"credential\"t\n" +
	"\x1aPyPIUnauthenticatedPackage\x12H\n" +
	"\x0funauthenticated\x18\x01 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticatedB\f\n" +
	"\n" +
	"credential\"\xde\x03\n" +
	"\x02S3\x127\n" +
	"\n" +
	"access_key\x18\x01 \x01(\v2\x16.credentials.KeySecretH\x00R\taccessKey\x12H\n" +
	"\x0funauthenticated\x18\x02 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x12L\n" +
	"\x11cloud_environment\x18\x04 \x01(\v2\x1d.credentials.CloudEnvironmentH\x00R\x10cloudEnvironment\x12I\n" +
	"\rsession_token\x18\x05 \x01(\v2\".credentials.AWSSessionTokenSecretH\x00R\fsessionToken\x12\x18\n" +
	"\abuckets\x18\x03 \x03(\tR\abuckets\x12&\n" +
	"\x0fmax_object_size\x18\x06 \x01(\x03R\rmaxObjectSize\x12\x14\n" +
	"\x05roles\x18\a \x03(\tR\x05roles\x12%\n" +
	"\x0eignore_buckets\x18\b \x03(\tR\rignoreBuckets\x12/\n" +
	"\x11enable_resumption\x18\t \x01(\bB\x02\x18\x01R\x10enableResumptionB\f\n" +
	"\n" +
	"credential\"\xc4\x01\n" +
	"\x05Slack\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x12\x16\n" +
	"\x05token\x18\x02 \x01(\tH\x00R\x05token\x122\n" +
	"\x06tokens\x18\x05 \x01(\v2\x18.credentials.SlackTokensH\x00R\x06tokens\x12\x1a\n" +
	"\bchannels\x18\x03 \x03(\tR\bchannels\x12\x1f\n" +
	"\vignore_list\x18\x04 \x03(\tR\n" +
	"ignoreListB\f\n" +
	"\n" +
	"credential\"\x06\n" +
	"\x04Test\"1\n" +
	"\tBuildkite\x12\x16\n" +
	"\x05token\x18\x01 \x01(\tH\x00R\x05tokenB\f\n" +
	"\n" +
	"credential\"\xa5\x02\n" +
	"\x06Gerrit\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x127\n" +
	"\n" +
	"basic_auth\x18\x02 \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuth\x12H\n" +
	"\x0funauthenticated\x18\x03 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x12\x1a\n" +
	"\bprojects\x18\x04 \x03(\tR\bprojects\x12#\n" +
	"\rskip_binaries\x18\x05 \x01(\bR\fskipBinaries\x12#\n" +
	"\rskip_archives\x18\x06 \x01(\bR\fskipArchivesB\f\n" +
	"\n" +
	"credential\"\xa8\x02\n" +
	"\aJenkins\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x127\n" +
	"\n" +
	"basic_auth\x18\x02 \x01(\v2\x16.credentials.BasicAuthH\x00R\tbasicAuth\x12-\n" +
	"\x06header\x18\x03 \x01(\v2\x13.credentials.HeaderH\x00R\x06header\x12H\n" +
	"\x0funauthenticated\x18\x05 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x127\n" +
	"\x18insecure_skip_verify_tls\x18\x04 \x01(\bR\x15insecureSkipVerifyTlsB\f\n" +
	"\n" +
	"credential\"\xbd\x02\n" +
	"\x05Teams\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x12\x16\n" +
	"\x05token\x18\x02 \x01(\tH\x00R\x05token\x12F\n" +
	"\rauthenticated\x18\x03 \x01(\v2\x1e.credentials.ClientCredentialsH\x00R\rauthenticated\x12+\n" +
	"\x05oauth\x18\a \x01(\v2\x13.credentials.Oauth2H\x00R\x05oauth\x12\x1a\n" +
	"\bchannels\x18\x04 \x03(\tR\bchannels\x12\x1f\n" +
	"\vignore_list\x18\x05 \x03(\tR\n" +
	"ignoreList\x12\x19\n" +
	"\bteam_ids\x18\x06 \x03(\tR\ateamIds\x12\x1b\n" +
	"\ttenant_id\x18\b \x01(\tR\btenantIdB\f\n" +
	"\n" +
	"credential\"\x95\x01\n" +
	"\x06Syslog\x12\x1a\n" +
	"\bprotocol\x18\x01 \x01(\tR\bprotocol\x12%\n" +
	"\x0elisten_address\x18\x02 \x01(\tR\rlistenAddress\x12\x18\n" +
	"\atlsCert\x18\x03 \x01(\tR\atlsCert\x12\x16\n" +
	"\x06tlsKey\x18\x04 \x01(\tR\x06tlsKey\x12\x16\n" +
	"\x06format\x18\x05 \x01(\tR\x06format\"\xca\x01\n" +
	"\aForager\x12H\n" +
	"\x0funauthenticated\x18\x01 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x12\x18\n" +
	"\adomains\x18\x02 \x03(\tR\adomains\x12\x1b\n" +
	"\tmax_depth\x18\x03 \x01(\x03R\bmaxDepth\x120\n" +
	"\x05since\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\x05sinceB\f\n" +
	"\n" +
	"credential\"Q\n" +
	"\rSlackRealtime\x122\n" +
	"\x06tokens\x18\x01 \x01(\v2\x18.credentials.SlackTokensH\x00R\x06tokensB\f\n" +
	"\n" +
	"credential\"b\n" +
	"\n" +
	"Sharepoint\x12+\n" +
	"\x05oauth\x18\x01 \x01(\v2\x13.credentials.Oauth2H\x00R\x05oauth\x12\x19\n" +
	"\bsite_url\x18\x02 \x01(\tR\asiteUrlB\f\n" +
	"\n" +
	"credential\"\xf6\x03\n" +
	"\n" +
	"AzureRepos\x12$\n" +
	"\bendpoint\x18\x01 \x01(\tB\b\xfaB\x05r\x03\x90\x01\x01R\bendpoint\x12\x16\n" +
	"\x05token\x18\x02 \x01(\tH\x00R\x05token\x12+\n" +
	"\x05oauth\x18\x03 \x01(\v2\x13.credentials.Oauth2H\x00R\x05oauth\x12\"\n" +
	"\frepositories\x18\x04 \x03(\tR\frepositories\x12$\n" +
	"\rorganizations\x18\x05 \x03(\tR\rorganizations\x12\x1a\n" +
	"\bprojects\x18\x06 \x03(\tR\bprojects\x12#\n" +
	"\rinclude_forks\x18\a \x01(\bR\fincludeForks\x12!\n" +
	"\fignore_repos\x18\b \x03(\tR\vignoreRepos\x12#\n" +
	"\rinclude_repos\x18\t \x03(\tR\fincludeRepos\x12)\n" +
	"\x10include_projects\x18\n" +
	" \x03(\tR\x0fincludeProjects\x12'\n" +
	"\x0fignore_projects\x18\v \x03(\tR\x0eignoreProjects\x12#\n" +
	"\rskip_binaries\x18\f \x01(\bR\fskipBinaries\x12#\n" +
	"\rskip_archives\x18\r \x01(\bR\fskipArchivesB\f\n" +
	"\n" +
	"credential\"\xd5\x04\n" +
	"\aPostman\x12H\n" +
	"\x0funauthenticated\x18\x01 \x01(\v2\x1c.credentials.UnauthenticatedH\x00R\x0funauthenticated\x12\x16\n" +
	"\x05token\x18\x02 \x01(\tH\x00R\x05token\x12\x1e\n" +
	"\n" +
	"workspaces\x18\x03 \x03(\tR\n" +
	"workspaces\x12 \n" +
	"\vcollections\x18\x04 \x03(\tR\vcollections\x12\"\n" +
	"\fenvironments\x18\x05 \x03(\tR\fenvironments\x12/\n" +
	"\x13exclude_collections\x18\x06 \x03(\tR\x12excludeCollections\x121\n" +
	"\x14exclude_environments\x18\a \x03(\tR\x13excludeEnvironments\x12/\n" +
	"\x13include_collections\x18\b \x03(\tR\x12includeCollections\x121\n" +
	"\x14include_environments\x18\t \x03(\tR\x13includeEnvironments\x12+\n" +
	"\x11detector_keywords\x18\n" +
	" \x03(\tR\x10detectorKeywords\x12'\n" +
	"\x0fworkspace_paths\x18\v \x03(\tR\x0eworkspacePaths\x12)\n" +
	"\x10collection_paths\x18\f \x03(\tR\x0fcollectionPaths\x12+\n" +
	"\x11environment_paths\x18\r \x03(\tR\x10environmentPathsB\f\n" +
	"\n" +
	"credential\"v\n" +
	"\aWebhook\x12.\n" +
	"\x0elisten_address\x18\x01 \x01(\tB\a\xfaB\x04r\x02h\x01R\rlistenAddress\x12-\n" +
	"\x06header\x18\x02 \x01(\v2\x13.credentials.HeaderH\x00R\x06headerB\f\n" +
	"\n" +
	"credential\"\x8b\x01\n" +
	"\x0fSlackContinuous\x12\x1d\n" +
	"\n" +
	"project_id\x18\x01 \x01(\tR\tprojectId\x12\x14\n" +
	"\x05topic\x18\x02 \x01(\tR\x05topic\x12\"\n" +
	"\fsubscription\x18\x03 \x01(\tR\fsubscription\x12\x1f\n" +
	"\vprivate_key\x18\x04 \x01(\fR\n" +
	"privateKey\"\xcd\x02\n" +
	"\rElasticsearch\x12\x14\n" +
	"\x05nodes\x18\x01 \x03(\tR\x05nodes\x12\x1a\n" +
	"\busername\x18\x02 \x01(\tR\busername\x12\x1a\n" +
	"\bpassword\x18\x03 \x01(\tR\bpassword\x12\x19\n" +
	"\bcloud_id\x18\x04 \x01(\tR\acloudId\x12\x17\n" +
	"\aapi_key\x18\x05 \x01(\tR\x06apiKey\x12#\n" +
	"\rservice_token\x18\x06 \x01(\tR\fserviceToken\x12#\n" +
	"\rindex_pattern\x18\a \x01(\tR\findexPattern\x12\x1d\n" +
	"\n" +
	"query_json\x18\b \x01(\tR\tqueryJson\x12'\n" +
	"\x0fsince_timestamp\x18\t \x01(\tR\x0esinceTimestamp\x12(\n" +
	"\x10best_effort_scan\x18\n" +
	" \x01(\bR\x0ebestEffortScan\"\xde\x01\n" +
	"\x06Sentry\x12\x1a\n" +
	"\bendpoint\x18\x01 \x01(\tR\bendpoint\x12\x1f\n" +
	"\n" +
	"auth_token\x18\x02 \x01(\tH\x00R\tauthToken\x12\x19\n" +
	"\adsn_key\x18\x03 \x01(\tH\x00R\x06dsnKey\x12\x19\n" +
	"\aapi_key\x18\x04 \x01(\tH\x00R\x06apiKey\x127\n" +
	"\x18insecure_skip_verify_tls\x18\x05 \x01(\bR\x15insecureSkipVerifyTls\x12\x1a\n" +
	"\bprojects\x18\x06 \x01(\tR\bprojectsB\f\n" +
	"\n" +
	"credential\"\a\n" +
	"\x05Stdin*\xa3\t\n" +
	"\n" +
	"SourceType\x12\x1d\n" +
	"\x19SOURCE_TYPE_AZURE_STORAGE\x10\x00\x12\x19\n" +
	"\x15SOURCE_TYPE_BITBUCKET\x10\x01\x12\x18\n" +
	"\x14SOURCE_TYPE_CIRCLECI\x10\x02\x12\x1a\n" +
	"\x16SOURCE_TYPE_CONFLUENCE\x10\x03\x12\x16\n" +
	"\x12SOURCE_TYPE_DOCKER\x10\x04\x12\x13\n" +
	"\x0fSOURCE_TYPE_ECR\x10\x05\x12\x13\n" +
	"\x0fSOURCE_TYPE_GCS\x10\x06\x12\x16\n" +
	"\x12SOURCE_TYPE_GITHUB\x10\a\x12\x1a\n" +
	"\x16SOURCE_TYPE_PUBLIC_GIT\x10\b\x12\x16\n" +
	"\x12SOURCE_TYPE_GITLAB\x10\t\x12\x14\n" +
	"\x10SOURCE_TYPE_JIRA\x10\n" +
	"\x12$\n" +
	" SOURCE_TYPE_NPM_UNAUTHD_PACKAGES\x10\v\x12%\n" +
	"!SOURCE_TYPE_PYPI_UNAUTHD_PACKAGES\x10\f\x12\x12\n" +
	"\x0eSOURCE_TYPE_S3\x10\r\x12\x15\n" +
	"\x11SOURCE_TYPE_SLACK\x10\x0e\x12\x1a\n" +
	"\x16SOURCE_TYPE_FILESYSTEM\x10\x0f\x12\x13\n" +
	"\x0fSOURCE_TYPE_GIT\x10\x10\x12\x14\n" +
	"\x10SOURCE_TYPE_TEST\x10\x11\x12\x1b\n" +
	"\x17SOURCE_TYPE_S3_UNAUTHED\x10\x12\x12*\n" +
	"&SOURCE_TYPE_GITHUB_UNAUTHENTICATED_ORG\x10\x13\x12\x19\n" +
	"\x15SOURCE_TYPE_BUILDKITE\x10\x14\x12\x16\n" +
	"\x12SOURCE_TYPE_GERRIT\x10\x15\x12\x17\n" +
	"\x13SOURCE_TYPE_JENKINS\x10\x16\x12\x15\n" +
	"\x11SOURCE_TYPE_TEAMS\x10\x17\x12!\n" +
	"\x1dSOURCE_TYPE_JFROG_ARTIFACTORY\x10\x18\x12\x16\n" +
	"\x12SOURCE_TYPE_SYSLOG\x10\x19\x12'\n" +
	"#SOURCE_TYPE_PUBLIC_EVENT_MONITORING\x10\x1a\x12\x1e\n" +
	"\x1aSOURCE_TYPE_SLACK_REALTIME\x10\x1b\x12\x1c\n" +
	"\x18SOURCE_TYPE_GOOGLE_DRIVE\x10\x1c\x12\x1a\n" +
	"\x16SOURCE_TYPE_SHAREPOINT\x10\x1d\x12\x1c\n" +
	"\x18SOURCE_TYPE_GCS_UNAUTHED\x10\x1e\x12\x1b\n" +
	"\x17SOURCE_TYPE_AZURE_REPOS\x10\x1f\x12\x18\n" +
	"\x14SOURCE_TYPE_TRAVISCI\x10 \x12\x17\n" +
	"\x13SOURCE_TYPE_POSTMAN\x10!\x12\x17\n" +
	"\x13SOURCE_TYPE_WEBHOOK\x10\"\x12\x1d\n" +
	"\x19SOURCE_TYPE_ELASTICSEARCH\x10#\x12\x1b\n" +
	"\x17SOURCE_TYPE_HUGGINGFACE\x10$\x12#\n" +
	"\x1fSOURCE_TYPE_GITHUB_EXPERIMENTAL\x10%\x12\x16\n" +
	"\x12SOURCE_TYPE_SENTRY\x10&\x12\x1f\n" +
	"\x1bSOURCE_TYPE_GITHUB_REALTIME\x10'\x12\x15\n" +
	"\x11SOURCE_TYPE_STDIN\x10(\x12 \n" +
	"\x1cSOURCE_TYPE_SLACK_CONTINUOUS\x10)*G\n" +
	"\x19BitbucketInstallationType\x12\x0e\n" +
	"\n" +
	"AUTODETECT\x10\x00\x12\t\n" +
	"\x05CLOUD\x10\x01\x12\x0f\n" +
	"\vDATA_CENTER\x10\x02B;Z9github.com/trufflesecurity/trufflehog/v3/pkg/pb/sourcespbb\x06proto3"

var (
	file_sources_proto_rawDescOnce sync.Once
	file_sources_proto_rawDescData []byte
)

func file_sources_proto_rawDescGZIP() []byte {
	file_sources_proto_rawDescOnce.Do(func() {
		file_sources_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_sources_proto_rawDesc), len(file_sources_proto_rawDesc)))
	})
	return file_sources_proto_rawDescData
}

var file_sources_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_sources_proto_msgTypes = make([]protoimpl.MessageInfo, 39)
var file_sources_proto_goTypes = []any{
	(SourceType)(0),                             // 0: sources.SourceType
	(BitbucketInstallationType)(0),              // 1: sources.BitbucketInstallationType
	(Confluence_GetAllSpacesScope)(0),           // 2: sources.Confluence.GetAllSpacesScope
	(*LocalSource)(nil),                         // 3: sources.LocalSource
	(*Artifactory)(nil),                         // 4: sources.Artifactory
	(*AzureStorage)(nil),                        // 5: sources.AzureStorage
	(*Bitbucket)(nil),                           // 6: sources.Bitbucket
	(*CircleCI)(nil),                            // 7: sources.CircleCI
	(*TravisCI)(nil),                            // 8: sources.TravisCI
	(*Confluence)(nil),                          // 9: sources.Confluence
	(*Docker)(nil),                              // 10: sources.Docker
	(*ECR)(nil),                                 // 11: sources.ECR
	(*Filesystem)(nil),                          // 12: sources.Filesystem
	(*GCS)(nil),                                 // 13: sources.GCS
	(*Git)(nil),                                 // 14: sources.Git
	(*GitLab)(nil),                              // 15: sources.GitLab
	(*GitHub)(nil),                              // 16: sources.GitHub
	(*GitHubExperimental)(nil),                  // 17: sources.GitHubExperimental
	(*GitHubRealtime)(nil),                      // 18: sources.GitHubRealtime
	(*GoogleDrive)(nil),                         // 19: sources.GoogleDrive
	(*Huggingface)(nil),                         // 20: sources.Huggingface
	(*JIRA)(nil),                                // 21: sources.JIRA
	(*NPMUnauthenticatedPackage)(nil),           // 22: sources.NPMUnauthenticatedPackage
	(*PyPIUnauthenticatedPackage)(nil),          // 23: sources.PyPIUnauthenticatedPackage
	(*S3)(nil),                                  // 24: sources.S3
	(*Slack)(nil),                               // 25: sources.Slack
	(*Test)(nil),                                // 26: sources.Test
	(*Buildkite)(nil),                           // 27: sources.Buildkite
	(*Gerrit)(nil),                              // 28: sources.Gerrit
	(*Jenkins)(nil),                             // 29: sources.Jenkins
	(*Teams)(nil),                               // 30: sources.Teams
	(*Syslog)(nil),                              // 31: sources.Syslog
	(*Forager)(nil),                             // 32: sources.Forager
	(*SlackRealtime)(nil),                       // 33: sources.SlackRealtime
	(*Sharepoint)(nil),                          // 34: sources.Sharepoint
	(*AzureRepos)(nil),                          // 35: sources.AzureRepos
	(*Postman)(nil),                             // 36: sources.Postman
	(*Webhook)(nil),                             // 37: sources.Webhook
	(*SlackContinuous)(nil),                     // 38: sources.SlackContinuous
	(*Elasticsearch)(nil),                       // 39: sources.Elasticsearch
	(*Sentry)(nil),                              // 40: sources.Sentry
	(*Stdin)(nil),                               // 41: sources.Stdin
	(*durationpb.Duration)(nil),                 // 42: google.protobuf.Duration
	(*anypb.Any)(nil),                           // 43: google.protobuf.Any
	(*credentialspb.BasicAuth)(nil),             // 44: credentials.BasicAuth
	(*credentialspb.Unauthenticated)(nil),       // 45: credentials.Unauthenticated
	(*credentialspb.Oauth2)(nil),                // 46: credentials.Oauth2
	(*credentialspb.KeySecret)(nil),             // 47: credentials.KeySecret
	(*credentialspb.CloudEnvironment)(nil),      // 48: credentials.CloudEnvironment
	(*credentialspb.SSHAuth)(nil),               // 49: credentials.SSHAuth
	(*credentialspb.GitHubApp)(nil),             // 50: credentials.GitHubApp
	(*credentialspb.AWSSessionTokenSecret)(nil), // 51: credentials.AWSSessionTokenSecret
	(*credentialspb.SlackTokens)(nil),           // 52: credentials.SlackTokens
	(*credentialspb.Header)(nil),                // 53: credentials.Header
	(*credentialspb.ClientCredentials)(nil),     // 54: credentials.ClientCredentials
	(*timestamppb.Timestamp)(nil),               // 55: google.protobuf.Timestamp
}
var file_sources_proto_depIdxs = []int32{
	42, // 0: sources.LocalSource.scan_interval:type_name -> google.protobuf.Duration
	43, // 1: sources.LocalSource.connection:type_name -> google.protobuf.Any
	44, // 2: sources.Artifactory.basic_auth:type_name -> credentials.BasicAuth
	45, // 3: sources.Artifactory.unauthenticated:type_name -> credentials.Unauthenticated
	44, // 4: sources.AzureStorage.basic_auth:type_name -> credentials.BasicAuth
	45, // 5: sources.AzureStorage.unauthenticated:type_name -> credentials.Unauthenticated
	46, // 6: sources.Bitbucket.oauth:type_name -> credentials.Oauth2
	44, // 7: sources.Bitbucket.basic_auth:type_name -> credentials.BasicAuth
	1,  // 8: sources.Bitbucket.installation_type:type_name -> sources.BitbucketInstallationType
	45, // 9: sources.Confluence.unauthenticated:type_name -> credentials.Unauthenticated
	44, // 10: sources.Confluence.basic_auth:type_name -> credentials.BasicAuth
	2,  // 11: sources.Confluence.spaces_scope:type_name -> sources.Confluence.GetAllSpacesScope
	45, // 12: sources.Docker.unauthenticated:type_name -> credentials.Unauthenticated
	44, // 13: sources.Docker.basic_auth:type_name -> credentials.BasicAuth
	47, // 14: sources.ECR.access_key:type_name -> credentials.KeySecret
	45, // 15: sources.GCS.unauthenticated:type_name -> credentials.Unauthenticated
	48, // 16: sources.GCS.adc:type_name -> credentials.CloudEnvironment
	46, // 17: sources.GCS.oauth:type_name -> credentials.Oauth2
	44, // 18: sources.Git.basic_auth:type_name -> credentials.BasicAuth
	45, // 19: sources.Git.unauthenticated:type_name -> credentials.Unauthenticated
	49, // 20: sources.Git.ssh_auth:type_name -> credentials.SSHAuth
	46, // 21: sources.GitLab.oauth:type_name -> credentials.Oauth2
	44, // 22: sources.GitLab.basic_auth:type_name -> credentials.BasicAuth
	50, // 23: sources.GitHub.github_app:type_name -> credentials.GitHubApp
	45, // 24: sources.GitHub.unauthenticated:type_name -> credentials.Unauthenticated
	44, // 25: sources.GitHub.basic_auth:type_name -> credentials.BasicAuth
	50, // 26: sources.GitHubRealtime.github_app:type_name -> credentials.GitHubApp
	45, // 27: sources.GitHubRealtime.unauthenticated:type_name -> credentials.Unauthenticated
	44, // 28: sources.GitHubRealtime.basic_auth:type_name -> credentials.BasicAuth
	45, // 29: sources.Huggingface.unauthenticated:type_name -> credentials.Unauthenticated
	44, // 30: sources.JIRA.basic_auth:type_name -> credentials.BasicAuth
	45, // 31: sources.JIRA.unauthenticated:type_name -> credentials.Unauthenticated
	46, // 32: sources.JIRA.oauth:type_name -> credentials.Oauth2
	45, // 33: sources.NPMUnauthenticatedPackage.unauthenticated:type_name -> credentials.Unauthenticated
	45, // 34: sources.PyPIUnauthenticatedPackage.unauthenticated:type_name -> credentials.Unauthenticated
	47, // 35: sources.S3.access_key:type_name -> credentials.KeySecret
	45, // 36: sources.S3.unauthenticated:type_name -> credentials.Unauthenticated
	48, // 37: sources.S3.cloud_environment:type_name -> credentials.CloudEnvironment
	51, // 38: sources.S3.session_token:type_name -> credentials.AWSSessionTokenSecret
	52, // 39: sources.Slack.tokens:type_name -> credentials.SlackTokens
	44, // 40: sources.Gerrit.basic_auth:type_name -> credentials.BasicAuth
	45, // 41: sources.Gerrit.unauthenticated:type_name -> credentials.Unauthenticated
	44, // 42: sources.Jenkins.basic_auth:type_name -> credentials.BasicAuth
	53, // 43: sources.Jenkins.header:type_name -> credentials.Header
	45, // 44: sources.Jenkins.unauthenticated:type_name -> credentials.Unauthenticated
	54, // 45: sources.Teams.authenticated:type_name -> credentials.ClientCredentials
	46, // 46: sources.Teams.oauth:type_name -> credentials.Oauth2
	45, // 47: sources.Forager.unauthenticated:type_name -> credentials.Unauthenticated
	55, // 48: sources.Forager.since:type_name -> google.protobuf.Timestamp
	52, // 49: sources.SlackRealtime.tokens:type_name -> credentials.SlackTokens
	46, // 50: sources.Sharepoint.oauth:type_name -> credentials.Oauth2
	46, // 51: sources.AzureRepos.oauth:type_name -> credentials.Oauth2
	45, // 52: sources.Postman.unauthenticated:type_name -> credentials.Unauthenticated
	53, // 53: sources.Webhook.header:type_name -> credentials.Header
	54, // [54:54] is the sub-list for method output_type
	54, // [54:54] is the sub-list for method input_type
	54, // [54:54] is the sub-list for extension type_name
	54, // [54:54] is the sub-list for extension extendee
	0,  // [0:54] is the sub-list for field type_name
}

func init() { file_sources_proto_init() }
func file_sources_proto_init() {
	if File_sources_proto != nil {
		return
	}
	file_sources_proto_msgTypes[1].OneofWrappers = []any{
		(*Artifactory_BasicAuth)(nil),
		(*Artifactory_AccessToken)(nil),
		(*Artifactory_Unauthenticated)(nil),
	}
	file_sources_proto_msgTypes[2].OneofWrappers = []any{
		(*AzureStorage_ConnectionString)(nil),
		(*AzureStorage_BasicAuth)(nil),
		(*AzureStorage_ClientCertificate)(nil),
		(*AzureStorage_Unauthenticated)(nil),
	}
	file_sources_proto_msgTypes[3].OneofWrappers = []any{
		(*Bitbucket_Token)(nil),
		(*Bitbucket_Oauth)(nil),
		(*Bitbucket_BasicAuth)(nil),
	}
	file_sources_proto_msgTypes[4].OneofWrappers = []any{
		(*CircleCI_Token)(nil),
	}
	file_sources_proto_msgTypes[5].OneofWrappers = []any{
		(*TravisCI_Token)(nil),
	}
	file_sources_proto_msgTypes[6].OneofWrappers = []any{
		(*Confluence_Unauthenticated)(nil),
		(*Confluence_BasicAuth)(nil),
		(*Confluence_Token)(nil),
	}
	file_sources_proto_msgTypes[7].OneofWrappers = []any{
		(*Docker_Unauthenticated)(nil),
		(*Docker_BasicAuth)(nil),
		(*Docker_BearerToken)(nil),
		(*Docker_DockerKeychain)(nil),
	}
	file_sources_proto_msgTypes[8].OneofWrappers = []any{
		(*ECR_AccessKey)(nil),
	}
	file_sources_proto_msgTypes[10].OneofWrappers = []any{
		(*GCS_JsonServiceAccount)(nil),
		(*GCS_ApiKey)(nil),
		(*GCS_Unauthenticated)(nil),
		(*GCS_Adc)(nil),
		(*GCS_ServiceAccountFile)(nil),
		(*GCS_Oauth)(nil),
	}
	file_sources_proto_msgTypes[11].OneofWrappers = []any{
		(*Git_BasicAuth)(nil),
		(*Git_Unauthenticated)(nil),
		(*Git_SshAuth)(nil),
	}
	file_sources_proto_msgTypes[12].OneofWrappers = []any{
		(*GitLab_Token)(nil),
		(*GitLab_Oauth)(nil),
		(*GitLab_BasicAuth)(nil),
	}
	file_sources_proto_msgTypes[13].OneofWrappers = []any{
		(*GitHub_GithubApp)(nil),
		(*GitHub_Token)(nil),
		(*GitHub_Unauthenticated)(nil),
		(*GitHub_BasicAuth)(nil),
	}
	file_sources_proto_msgTypes[14].OneofWrappers = []any{
		(*GitHubExperimental_Token)(nil),
	}
	file_sources_proto_msgTypes[15].OneofWrappers = []any{
		(*GitHubRealtime_GithubApp)(nil),
		(*GitHubRealtime_Token)(nil),
		(*GitHubRealtime_Unauthenticated)(nil),
		(*GitHubRealtime_BasicAuth)(nil),
	}
	file_sources_proto_msgTypes[16].OneofWrappers = []any{
		(*GoogleDrive_RefreshToken)(nil),
	}
	file_sources_proto_msgTypes[17].OneofWrappers = []any{
		(*Huggingface_Token)(nil),
		(*Huggingface_Unauthenticated)(nil),
	}
	file_sources_proto_msgTypes[18].OneofWrappers = []any{
		(*JIRA_BasicAuth)(nil),
		(*JIRA_Unauthenticated)(nil),
		(*JIRA_Oauth)(nil),
		(*JIRA_Token)(nil),
	}
	file_sources_proto_msgTypes[19].OneofWrappers = []any{
		(*NPMUnauthenticatedPackage_Unauthenticated)(nil),
	}
	file_sources_proto_msgTypes[20].OneofWrappers = []any{
		(*PyPIUnauthenticatedPackage_Unauthenticated)(nil),
	}
	file_sources_proto_msgTypes[21].OneofWrappers = []any{
		(*S3_AccessKey)(nil),
		(*S3_Unauthenticated)(nil),
		(*S3_CloudEnvironment)(nil),
		(*S3_SessionToken)(nil),
	}
	file_sources_proto_msgTypes[22].OneofWrappers = []any{
		(*Slack_Token)(nil),
		(*Slack_Tokens)(nil),
	}
	file_sources_proto_msgTypes[24].OneofWrappers = []any{
		(*Buildkite_Token)(nil),
	}
	file_sources_proto_msgTypes[25].OneofWrappers = []any{
		(*Gerrit_BasicAuth)(nil),
		(*Gerrit_Unauthenticated)(nil),
	}
	file_sources_proto_msgTypes[26].OneofWrappers = []any{
		(*Jenkins_BasicAuth)(nil),
		(*Jenkins_Header)(nil),
		(*Jenkins_Unauthenticated)(nil),
	}
	file_sources_proto_msgTypes[27].OneofWrappers = []any{
		(*Teams_Token)(nil),
		(*Teams_Authenticated)(nil),
		(*Teams_Oauth)(nil),
	}
	file_sources_proto_msgTypes[29].OneofWrappers = []any{
		(*Forager_Unauthenticated)(nil),
	}
	file_sources_proto_msgTypes[30].OneofWrappers = []any{
		(*SlackRealtime_Tokens)(nil),
	}
	file_sources_proto_msgTypes[31].OneofWrappers = []any{
		(*Sharepoint_Oauth)(nil),
	}
	file_sources_proto_msgTypes[32].OneofWrappers = []any{
		(*AzureRepos_Token)(nil),
		(*AzureRepos_Oauth)(nil),
	}
	file_sources_proto_msgTypes[33].OneofWrappers = []any{
		(*Postman_Unauthenticated)(nil),
		(*Postman_Token)(nil),
	}
	file_sources_proto_msgTypes[34].OneofWrappers = []any{
		(*Webhook_Header)(nil),
	}
	file_sources_proto_msgTypes[37].OneofWrappers = []any{
		(*Sentry_AuthToken)(nil),
		(*Sentry_DsnKey)(nil),
		(*Sentry_ApiKey)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_sources_proto_rawDesc), len(file_sources_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   39,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_sources_proto_goTypes,
		DependencyIndexes: file_sources_proto_depIdxs,
		EnumInfos:         file_sources_proto_enumTypes,
		MessageInfos:      file_sources_proto_msgTypes,
	}.Build()
	File_sources_proto = out.File
	file_sources_proto_goTypes = nil
	file_sources_proto_depIdxs = nil
}
