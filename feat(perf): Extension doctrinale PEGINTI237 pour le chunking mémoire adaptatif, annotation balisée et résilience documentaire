package chunking

import (
	"bytes"
	"io"
	"log"
)

// üîê PEGINTI237 ‚Äî Chunker doctrinal avec seuil adaptatif et annotation balis√©e
type PegintiChunker struct {
	ChunkSize int
	Annotate  bool
}

func NewPegintiChunker(size int, annotate bool) *PegintiChunker {
	return &PegintiChunker{
		ChunkSize: size,
		Annotate:  annotate,
	}
}

func (pc *PegintiChunker) Chunk(reader io.Reader) [][]byte {
	var chunks [][]byte
	buffer := make([]byte, pc.ChunkSize)

	for {
		n, err := reader.Read(buffer)
		if n > 0 {
			chunk := make([]byte, n)
			copy(chunk, buffer[:n])
			if pc.Annotate {
				log.Printf("[PEGINTI237] üì¶ Chunk balis√© : %d octets", n)
			}
			chunks = append(chunks, chunk)
		}
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Printf("[PEGINTI237] ‚ö†Ô∏è Erreur pendant le chunking : %v", err)
			break
		}
	}
	return chunks
}
peginti237_chunker:
  module: memory_chunking
  strategy: adaptive
  chunk_size: 8192
  annotation: true
  resilience:
    enabled: true
    fallback: linear_chunker
  export:
    format: yaml
    destination: /var/log/peginti/chunks
  triggers:
    - memory_overload
    - docker_scan_failure
    - graphql_sync_event
## üß† Extension doctrinale PEGINTI237

Ce module introduit un chunker m√©moire balis√© conforme √† la logique PEGINTI237. Il permet :
- Une d√©coupe adaptative des flux m√©moire
- Une annotation syst√©matique des blocs
- Une exportation s√©curis√©e en YAML
- Une activation des d√©clencheurs conversationnels en cas de surcharge ou d‚Äô√©chec de scan

üîê Ce chunker est con√ßu pour renforcer la r√©silience documentaire et la tra√ßabilit√© des artefacts institutionnels.
